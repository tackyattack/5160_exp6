C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 13:16:06 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE PLAYER
OBJECT MODULE PLACED IN .\player.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\player.c LARGE DEBUG OBJECTEXTEND PRINT(.\player.lst) OBJECT(.\pl
                    -ayer.obj) 

stmt level    source

   1          #include "main.h"
   2          #include "SDCard.h"
   3          #include "PORT.h"
   4          #include "player.h"
   5          #include "Outputs.h"
   6          #include "file_system.h"
   7          #include "Directory_Functions_struct.h"
   8          #include "sector_reader.h"
   9          #include "SPI.h"
  10          #include "LED_Control.h"
  11          #include <stdio.h>
  12          
  13          #define BUF_SIZE (512)
  14          extern uint8_t xdata buf1[BUF_SIZE];
  15          extern uint8_t xdata buf2[BUF_SIZE];
  16          
  17          
  18          typedef enum {find_cluster_1, data_idle_1, load_buffer_1, data_send_1,
  19                        find_cluster_2, data_idle_2, load_buffer_2, data_send_2, song_end} player_state_t;
  20          player_state_t player_state;
  21          
  22          
  23          // might be active low
  24          #define DATA_REQ_ACTIVE   (DATA_REQ == 0)
  25          #define DATA_REQ_INACTIVE (DATA_REQ != 0)
  26          
  27          uint8_t idata *buffer1_flag;
  28          uint8_t idata *buffer2_flag;
  29          
  30          #define BUFFER_EMPTY (1)
  31          #define BUFFER_FULL  (0)
  32          
  33          uint16_t idata *index1;
  34          uint16_t idata *index2;
  35          
  36          
  37          uint32_t idata *base_sector;
  38          uint32_t idata *sector_offset;
  39          uint32_t idata *current_cluster;
  40          static FS_values_t *drive_values;
  41          
  42          void set_data_pool_player(uint32_t *p32, uint16_t *p16, uint8_t *p8)
  43          {
  44   1        base_sector = p32 + 0;
  45   1        sector_offset = p32 + 1;
  46   1        current_cluster = p32 + 1;
  47   1      
  48   1        index1 = p16 + 0;
  49   1        index2 = p16 + 1;
  50   1      
  51   1        buffer1_flag = p8 + 0;
  52   1        buffer2_flag = p8 + 1;
  53   1      
  54   1      }
C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 13:16:06 PAGE 2   

  55          
  56          void load_sector(uint8_t *buf)
  57          {
  58   1        // check if we need to find the first sector of the cluster
  59   1        if(*sector_offset == 0) *base_sector = first_sector_i(*current_cluster);
  60   1        // read the sector in
  61   1        Read_Sector_i(((*base_sector) + (*sector_offset)), drive_values->BytesPerSec, buf);
  62   1        (*sector_offset)++; // go forward one sector
  63   1      }
  64          
  65          void init_player(uint32_t start_cluster)
  66          {
  67   1        player_state    = data_send_1;
  68   1        *buffer1_flag    = BUFFER_FULL;
  69   1        *buffer2_flag    = BUFFER_EMPTY;
  70   1        *index1          = 0;
  71   1        *index2          = 0;
  72   1        *base_sector     = first_sector(start_cluster);
  73   1        *sector_offset   = 0;
  74   1        *current_cluster = start_cluster;
  75   1        load_sector(buf1);
  76   1        //while(player_state_machine_runner() == PLAYER_RUNNING);
  77   1      }
  78          
  79          // flush out as much as the decoder will take
  80          uint8_t send_buffer(uint8_t *buf, uint16_t *index, uint8_t *buffer_flag)
  81          {
  82   1        uint8_t temp8;
  83   1        P1_set_bit(STA_SPI_BIT_EN_bit);
  84   1        for(;((*index)<BUF_SIZE)&&(DATA_REQ_ACTIVE); (*index)++) SPI_Transfer(buf[(*index)], &temp8);
  85   1        P1_clear_bit(STA_SPI_BIT_EN_bit);
  86   1        // check if we flushed the entire buffer
  87   1        // if there's still more to go, then the state machine will know since the buffer didn't
  88   1        // get set empty and it can continue sending when it's ready again
  89   1        if((*index) == BUF_SIZE)
  90   1        {
  91   2          (*index)=0;
  92   2          (*buffer_flag)=BUFFER_EMPTY;
  93   2          return 1;
  94   2        }
  95   1        return 0;
  96   1      }
  97          
  98          uint8_t player_state_machine_runner(void)
  99          {
 100   1        switch(player_state)
 101   1        {
 102   2          case find_cluster_1:
 103   2            LED_number(1);
 104   2            *current_cluster = find_next_clus_i(*current_cluster, buf1);
 105   2            if(*current_cluster != FAT_END_OF_FILE_MARKER)
 106   2            {
 107   3              *sector_offset = 0;
 108   3              player_state = data_idle_2;
 109   3            }
 110   2            else
 111   2            {
 112   3              player_state = song_end;
 113   3            }
 114   2            break;
 115   2          case data_idle_1:
 116   2            LED_number(2);
C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 13:16:06 PAGE 3   

 117   2            if(DATA_REQ_ACTIVE) player_state = data_send_1;
 118   2            break;
 119   2          case load_buffer_1:
 120   2            LED_number(3);
 121   2            // check if we hit the end of this cluster
 122   2            // if so, load the FAT sector into the open buffer, but don't indicate that it's
 123   2            // filled since it isn't data
 124   2            if(sector_offset == drive_values->SecPerClus)
 125   2            {
 126   3              player_state = find_cluster_1;
 127   3            }
 128   2            else
 129   2            {
 130   3              load_sector(buf1);
 131   3              *buffer1_flag = BUFFER_FULL;
 132   3              player_state = data_idle_2;
 133   3            }
 134   2            break;
 135   2          case data_send_1:
 136   2            LED_number(4);
 137   2            if(DATA_REQ_ACTIVE)
 138   2            {
 139   3              if(*buffer1_flag == BUFFER_FULL) send_buffer(buf1, index1, buffer1_flag);
 140   3            }
 141   2      
 142   2            if((DATA_REQ_INACTIVE && (*buffer2_flag==BUFFER_EMPTY))
 143   2                || ((*buffer1_flag==BUFFER_EMPTY) && (*buffer2_flag==BUFFER_EMPTY)))
 144   2            {
 145   3              // if we're inactive and buffer2 is empty, go fill it
 146   3              // OR, if both buffers are empty, go fill buffer2
 147   3              player_state = load_buffer_2;
 148   3            }
 149   2            else if((*buffer1_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 150   2            {
 151   3              // decoder wants data, but buffer1 was empty, so go check buffer2
 152   3              player_state = data_send_2;
 153   3            }
 154   2            else if(DATA_REQ_INACTIVE)
 155   2            {
 156   3              // if nothing else needs to be taken care of above, just go back to idle
 157   3              player_state = data_idle_1;
 158   3            }
 159   2            break;
 160   2          case find_cluster_2:
 161   2            LED_number(5);
 162   2            *current_cluster = find_next_clus_i(*current_cluster, buf2);
 163   2            if(*current_cluster != FAT_END_OF_FILE_MARKER)
 164   2            {
 165   3              *sector_offset = 0;
 166   3              player_state = data_idle_1;
 167   3            }
 168   2            else
 169   2            {
 170   3              player_state = song_end;
 171   3            }
 172   2            break;
 173   2          case data_idle_2:
 174   2            LED_number(6);
 175   2            if(DATA_REQ_ACTIVE) player_state = data_send_2;
 176   2            break;
 177   2          case load_buffer_2:
 178   2            LED_number(7);
C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 13:16:06 PAGE 4   

 179   2            // check if we hit the end of this cluster
 180   2            // if so, load the FAT sector into the open buffer, but don't indicate that it's
 181   2            // filled since it isn't data
 182   2            if(*sector_offset == drive_values->SecPerClus)
 183   2            {
 184   3              //check if we hit the end of this cluster
 185   3              player_state = find_cluster_2;
 186   3            }
 187   2            else
 188   2            {
 189   3              load_sector(buf2);
 190   3              *buffer2_flag = BUFFER_FULL;
 191   3              player_state = data_idle_1;
 192   3            }
 193   2            break;
 194   2          case data_send_2:
 195   2            LED_number(8);
 196   2            if(DATA_REQ_ACTIVE)
 197   2            {
 198   3              if(*buffer2_flag == BUFFER_FULL) send_buffer(buf2, index2, buffer2_flag);
 199   3            }
 200   2      
 201   2            // determine which state to go to next
 202   2            if((DATA_REQ_INACTIVE && (*buffer1_flag==BUFFER_EMPTY))
 203   2              || ((*buffer1_flag==BUFFER_EMPTY) && (*buffer2_flag==BUFFER_EMPTY)))
 204   2            {
 205   3              // if we're inactive and buffer1 is empty, go fill it
 206   3              // OR, if both buffers are empty, go fill buffer1
 207   3              player_state = load_buffer_1;
 208   3            }
 209   2            else if((*buffer2_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 210   2            {
 211   3              // decoder wants data, but buffer2 was empty, so go check buffer1
 212   3              player_state = data_send_1;
 213   3            }
 214   2            else if(DATA_REQ_INACTIVE)
 215   2            {
 216   3              // if nothing else needs to be taken care of above, just go back to idle
 217   3              player_state = data_idle_2;
 218   3            }
 219   2            break;
 220   2          case song_end:
 221   2            // do nothing -- outside functions could watch for this and do something while we stay here
 222   2            LED_number(9);
 223   2            break;
 224   2        }
 225   1      
 226   1        if(player_state == song_end) return PLAYER_COMPLETE;
 227   1        return PLAYER_RUNNING;
 228   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1120    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11      26
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
