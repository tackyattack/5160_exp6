C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 20:36:36 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE PLAYER
OBJECT MODULE PLACED IN .\player.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\player.c DEBUG OBJECTEXTEND PRINT(.\player.lst) OBJECT(.\player.o
                    -bj) 

stmt level    source

   1          #include "main.h"
   2          #include "SDCard.h"
   3          #include "PORT.h"
   4          #include "player.h"
   5          #include "Outputs.h"
   6          #include "file_system.h"
   7          #include "Directory_Functions_struct.h"
   8          #include "sector_reader.h"
   9          #include "SPI.h"
  10          #include "LED_Control.h"
  11          
  12          
  13          extern uint8_t xdata buf1[512];
  14          extern uint8_t xdata buf2[512];
  15          
  16          void player_state_machine_runner(void);
  17          
  18          
  19          typedef enum {find_cluster_1, data_idle_1, load_buffer_1, data_send_1,
  20                        find_cluster_2, data_idle_2, load_buffer_2, data_send_2} player_state_t;
  21          player_state_t player_state;
  22          
  23          #define BUF_SIZE (512)
  24          extern uint8_t xdata buf1[512];
  25          extern uint8_t xdata buf2[512];
  26          
  27          
  28          // might be active low
  29          #define DATA_REQ_ACTIVE   (DATA_REQ == 0)
  30          #define DATA_REQ_INACTIVE (DATA_REQ != 0)
  31          
  32          uint8_t buffer1_flag;
  33          uint8_t buffer2_flag;
  34          
  35          #define BUFFER_EMPTY (1)
  36          #define BUFFER_FULL  (0)
  37          
  38          uint16_t index1;
  39          uint16_t index2;
  40          
  41          
  42          uint32_t base_sector;
  43          uint32_t sector_offset;
  44          uint32_t current_cluster;
  45          static FS_values_t *drive_values;
  46          
  47          // assuming buf1 is filled first before calling this
  48          void init_player(uint32_t start_cluster, uint8_t xdata *buf)
  49          {
  50   1        player_state    = data_send_1;
  51   1        buffer1_flag    = BUFFER_EMPTY;
  52   1        buffer2_flag    = BUFFER_EMPTY;
  53   1        // check the pointer to see which buffer was loaded
  54   1        if(buf == buf1) buffer1_flag = BUFFER_FULL;
C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 20:36:36 PAGE 2   

  55   1        if(buf == buf2) buffer2_flag = BUFFER_FULL;
  56   1        index1          = 0;
  57   1        index2          = 0;
  58   1        drive_values    = Export_Drive_values();
  59   1        base_sector     = first_sector(start_cluster);
  60   1        sector_offset   = 0;
  61   1        current_cluster = start_cluster;
  62   1        while(1) player_state_machine_runner();
  63   1      }
  64          
  65          void load_sector(uint8_t *buf)
  66          {
  67   1        // check if we need to find the first sector of the cluster
  68   1      
  69   1        if(sector_offset == 0) base_sector = first_sector(current_cluster);
  70   1        // read the sector in
  71   1        Read_Sector((base_sector+sector_offset), drive_values->BytesPerSec, buf);
  72   1        sector_offset++; // go forward one sector
  73   1      }
  74          
  75          // flush out as much as the decoder will take
  76          uint8_t send_buffer(uint8_t *buf, uint16_t *index, uint8_t *buffer_flag)
  77          {
  78   1        uint8_t temp8;
  79   1        P1_set_bit(STA_SPI_BIT_EN_bit);
  80   1        for(;((*index)<BUF_SIZE)&&(DATA_REQ_ACTIVE); (*index)++) SPI_Transfer(buf[(*index)], &temp8);
  81   1        P1_clear_bit(STA_SPI_BIT_EN_bit);
  82   1        // check if we flushed the entire buffer
  83   1        // if there's still more to go, then the state machine will know since the buffer didn't
  84   1        // get set empty and it can continue sending when it's ready again
  85   1        if((*index) == BUF_SIZE)
  86   1        {
  87   2          (*index)=0;
  88   2          (*buffer_flag)=BUFFER_EMPTY;
  89   2          return 1;
  90   2        }
  91   1        return 0;
  92   1      }
  93          
  94          void LED_number(uint8_t num)
  95          {
  96   1        LEDS_OFF(Green_LED);
  97   1        LEDS_OFF(Amber_LED);
  98   1        LEDS_OFF(Yellow_LED);
  99   1        LEDS_OFF(Red_LED);
 100   1        if((num&(1<<0)) != 0) LEDS_ON(Green_LED);
 101   1        if((num&(1<<1)) != 0) LEDS_ON(Amber_LED);
 102   1        if((num&(1<<2)) != 0) LEDS_ON(Yellow_LED);
 103   1        if((num&(1<<3)) != 0) LEDS_ON(Red_LED);
 104   1      }
 105          
 106          void player_state_machine_runner(void)
 107          {
 108   1        switch(player_state)
 109   1        {
 110   2          case find_cluster_1:
 111   2            LED_number(1);
 112   2            current_cluster = find_next_clus(current_cluster, buf1);
 113   2            buffer1_flag = BUFFER_FULL;
 114   2            sector_offset = 0;
 115   2            player_state = data_idle_2;
 116   2            break;
C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 20:36:36 PAGE 3   

 117   2          case data_idle_1:
 118   2            LED_number(2);
 119   2            if(DATA_REQ_ACTIVE) player_state = data_send_1;
 120   2            break;
 121   2          case load_buffer_1:
 122   2            LED_number(3);
 123   2            load_sector(buf1);
 124   2            buffer1_flag = BUFFER_FULL;
 125   2            player_state = data_idle_2;
 126   2            break;
 127   2          case data_send_1:
 128   2            LED_number(4);
 129   2            if(DATA_REQ_ACTIVE)
 130   2            {
 131   3              if(buffer1_flag == BUFFER_FULL) send_buffer(buf1, &index1, &buffer1_flag);
 132   3            }
 133   2      
 134   2            // determine which state to go to next
 135   2            if(sector_offset == drive_values->SecPerClus)
 136   2            {
 137   3              //check if we hit the end of this cluster
 138   3              player_state = find_cluster_1;
 139   3            }
 140   2            if((DATA_REQ_INACTIVE && (buffer2_flag==BUFFER_EMPTY))
 141   2                || ((buffer1_flag==BUFFER_EMPTY) && (buffer2_flag==BUFFER_EMPTY)))
 142   2            {
 143   3              // if we're inactive and buffer2 is empty, go fill it
 144   3              // OR, if both buffers are empty, go fill buffer2
 145   3              player_state = load_buffer_2;
 146   3            }
 147   2            else if((buffer1_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 148   2            {
 149   3              // decoder wants data, but buffer1 was empty, so go check buffer2
 150   3              player_state = data_send_2;
 151   3            }
 152   2            else if(DATA_REQ_INACTIVE)
 153   2            {
 154   3              // if nothing else needs to be taken care of above, just go back to idle
 155   3              player_state = data_idle_1;
 156   3            }
 157   2            break;
 158   2          case find_cluster_2:
 159   2            LED_number(5);
 160   2            current_cluster = find_next_clus(current_cluster, buf2);
 161   2            buffer2_flag = BUFFER_FULL;
 162   2            sector_offset = 0;
 163   2            player_state = data_idle_1;
 164   2            break;
 165   2          case data_idle_2:
 166   2            LED_number(6);
 167   2            if(DATA_REQ_ACTIVE) player_state = data_send_2;
 168   2            break;
 169   2          case load_buffer_2:
 170   2            LED_number(7);
 171   2            load_sector(buf2);
 172   2            buffer2_flag = BUFFER_FULL;
 173   2            player_state = data_idle_1;
 174   2            break;
 175   2          case data_send_2:
 176   2            LED_number(8);
 177   2              if(DATA_REQ_ACTIVE)
 178   2              {
C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 20:36:36 PAGE 4   

 179   3                if(buffer2_flag == BUFFER_FULL) send_buffer(buf2, &index2, &buffer2_flag);
 180   3              }
 181   2      
 182   2              // determine which state to go to next
 183   2              if(sector_offset == drive_values->SecPerClus)
 184   2              {
 185   3                //check if we hit the end of this cluster
 186   3                player_state = find_cluster_2;
 187   3              }
 188   2              if((DATA_REQ_INACTIVE && (buffer1_flag==BUFFER_EMPTY))
 189   2                  || ((buffer1_flag==BUFFER_EMPTY) && (buffer1_flag==BUFFER_EMPTY)))
 190   2              {
 191   3                // if we're inactive and buffer1 is empty, go fill it
 192   3                // OR, if both buffers are empty, go fill buffer1
 193   3                player_state = load_buffer_1;
 194   3              }
 195   2              else if((buffer2_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 196   2              {
 197   3                // decoder wants data, but buffer2 was empty, so go check buffer1
 198   3                player_state = data_send_1;
 199   3              }
 200   2              else if(DATA_REQ_INACTIVE)
 201   2              {
 202   3                // if nothing else needs to be taken care of above, just go back to idle
 203   3                player_state = data_idle_2;
 204   3              }
 205   2      
 206   2            break;
 207   2        }
 208   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    821    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
