C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 23:40:30 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE PLAYER
OBJECT MODULE PLACED IN .\player.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\player.c DEBUG OBJECTEXTEND PRINT(.\player.lst) OBJECT(.\player.o
                    -bj) 

stmt level    source

   1          #include "main.h"
   2          #include "SDCard.h"
   3          #include "PORT.h"
   4          #include "player.h"
   5          #include "Outputs.h"
   6          #include "file_system.h"
   7          #include "Directory_Functions_struct.h"
   8          #include "sector_reader.h"
   9          #include "SPI.h"
  10          #include "LED_Control.h"
  11          
  12          #define BUF_SIZE (512)
  13          extern uint8_t xdata buf1[BUF_SIZE];
  14          extern uint8_t xdata buf2[BUF_SIZE];
  15          
  16          typedef enum {find_cluster_1, data_idle_1, load_buffer_1, data_send_1,
  17                        find_cluster_2, data_idle_2, load_buffer_2, data_send_2, song_end} player_state_t;
  18          player_state_t player_state;
  19          
  20          
  21          // might be active low
  22          #define DATA_REQ_ACTIVE   (DATA_REQ == 0)
  23          #define DATA_REQ_INACTIVE (DATA_REQ != 0)
  24          
  25          uint8_t buffer1_flag;
  26          uint8_t buffer2_flag;
  27          
  28          #define BUFFER_EMPTY (1)
  29          #define BUFFER_FULL  (0)
  30          
  31          uint16_t index1;
  32          uint16_t index2;
  33          
  34          
  35          uint32_t base_sector;
  36          uint32_t sector_offset;
  37          uint32_t current_cluster;
  38          static FS_values_t *drive_values;
  39          
  40          // assuming buf1 is filled first before calling this
  41          void init_player(uint32_t start_cluster, uint8_t xdata *buf)
  42          {
  43   1        player_state    = data_send_1;
  44   1        buffer1_flag    = BUFFER_EMPTY;
  45   1        buffer2_flag    = BUFFER_EMPTY;
  46   1        // check the pointer to see which buffer was loaded
  47   1        if(buf == buf1) buffer1_flag = BUFFER_FULL;
  48   1        if(buf == buf2) buffer2_flag = BUFFER_FULL;
  49   1        index1          = 0;
  50   1        index2          = 0;
  51   1        drive_values    = Export_Drive_values();
  52   1        base_sector     = first_sector(start_cluster);
  53   1        sector_offset   = 0;
  54   1        current_cluster = start_cluster;
C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 23:40:30 PAGE 2   

  55   1        while(player_state_machine_runner() == PLAYER_RUNNING);
  56   1      }
  57          
  58          void load_sector(uint8_t *buf)
  59          {
  60   1        // check if we need to find the first sector of the cluster
  61   1        if(sector_offset == 0) base_sector = first_sector(current_cluster);
  62   1        // read the sector in
  63   1        Read_Sector((base_sector+sector_offset), drive_values->BytesPerSec, buf);
  64   1        sector_offset++; // go forward one sector
  65   1      }
  66          
  67          // flush out as much as the decoder will take
  68          uint8_t send_buffer(uint8_t *buf, uint16_t *index, uint8_t *buffer_flag)
  69          {
  70   1        uint8_t temp8;
  71   1        P1_set_bit(STA_SPI_BIT_EN_bit);
  72   1        for(;((*index)<BUF_SIZE)&&(DATA_REQ_ACTIVE); (*index)++) SPI_Transfer(buf[(*index)], &temp8);
  73   1        P1_clear_bit(STA_SPI_BIT_EN_bit);
  74   1        // check if we flushed the entire buffer
  75   1        // if there's still more to go, then the state machine will know since the buffer didn't
  76   1        // get set empty and it can continue sending when it's ready again
  77   1        if((*index) == BUF_SIZE)
  78   1        {
  79   2          (*index)=0;
  80   2          (*buffer_flag)=BUFFER_EMPTY;
  81   2          return 1;
  82   2        }
  83   1        return 0;
  84   1      }
  85          
  86          void LED_number(uint8_t num)
  87          {
  88   1        LEDS_OFF(Green_LED);
  89   1        LEDS_OFF(Amber_LED);
  90   1        LEDS_OFF(Yellow_LED);
  91   1        LEDS_OFF(Red_LED);
  92   1        if((num&(1<<0)) != 0) LEDS_ON(Green_LED);
  93   1        if((num&(1<<1)) != 0) LEDS_ON(Amber_LED);
  94   1        if((num&(1<<2)) != 0) LEDS_ON(Yellow_LED);
  95   1        if((num&(1<<3)) != 0) LEDS_ON(Red_LED);
  96   1      }
  97          
  98          uint8_t player_state_machine_runner(void)
  99          {
 100   1        switch(player_state)
 101   1        {
 102   2          case find_cluster_1:
 103   2            LED_number(1);
 104   2            current_cluster = find_next_clus(current_cluster, buf1);
 105   2            if(current_cluster != FAT_END_OF_FILE_MARKER)
 106   2            {
 107   3              buffer1_flag = BUFFER_FULL;
 108   3              sector_offset = 0;
 109   3              player_state = data_idle_2;
 110   3            }
 111   2            else
 112   2            {
 113   3              player_state = song_end;
 114   3            }
 115   2            break;
 116   2          case data_idle_1:
C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 23:40:30 PAGE 3   

 117   2            LED_number(2);
 118   2            if(DATA_REQ_ACTIVE) player_state = data_send_1;
 119   2            break;
 120   2          case load_buffer_1:
 121   2            LED_number(3);
 122   2            load_sector(buf1);
 123   2            buffer1_flag = BUFFER_FULL;
 124   2            player_state = data_idle_2;
 125   2            break;
 126   2          case data_send_1:
 127   2            LED_number(4);
 128   2            if(DATA_REQ_ACTIVE)
 129   2            {
 130   3              if(buffer1_flag == BUFFER_FULL) send_buffer(buf1, &index1, &buffer1_flag);
 131   3            }
 132   2      
 133   2            // determine which state to go to next
 134   2            if(sector_offset == drive_values->SecPerClus)
 135   2            {
 136   3              //check if we hit the end of this cluster
 137   3              player_state = find_cluster_1;
 138   3            }
 139   2            else if((DATA_REQ_INACTIVE && (buffer2_flag==BUFFER_EMPTY))
 140   2                || ((buffer1_flag==BUFFER_EMPTY) && (buffer2_flag==BUFFER_EMPTY)))
 141   2            {
 142   3              // if we're inactive and buffer2 is empty, go fill it
 143   3              // OR, if both buffers are empty, go fill buffer2
 144   3              player_state = load_buffer_2;
 145   3            }
 146   2            else if((buffer1_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 147   2            {
 148   3              // decoder wants data, but buffer1 was empty, so go check buffer2
 149   3              player_state = data_send_2;
 150   3            }
 151   2            else if(DATA_REQ_INACTIVE)
 152   2            {
 153   3              // if nothing else needs to be taken care of above, just go back to idle
 154   3              player_state = data_idle_1;
 155   3            }
 156   2            break;
 157   2          case find_cluster_2:
 158   2            LED_number(5);
 159   2            current_cluster = find_next_clus(current_cluster, buf2);
 160   2            if(current_cluster != FAT_END_OF_FILE_MARKER)
 161   2            {
 162   3              buffer2_flag = BUFFER_FULL;
 163   3              sector_offset = 0;
 164   3              player_state = data_idle_1;
 165   3            }
 166   2            else
 167   2            {
 168   3              player_state = song_end;
 169   3            }
 170   2            break;
 171   2          case data_idle_2:
 172   2            LED_number(6);
 173   2            if(DATA_REQ_ACTIVE) player_state = data_send_2;
 174   2            break;
 175   2          case load_buffer_2:
 176   2            LED_number(7);
 177   2            load_sector(buf2);
 178   2            buffer2_flag = BUFFER_FULL;
C51 COMPILER V6.02  PLAYER                                                                 11/20/2019 23:40:30 PAGE 4   

 179   2            player_state = data_idle_1;
 180   2            break;
 181   2          case data_send_2:
 182   2            LED_number(8);
 183   2              if(DATA_REQ_ACTIVE)
 184   2              {
 185   3                if(buffer2_flag == BUFFER_FULL) send_buffer(buf2, &index2, &buffer2_flag);
 186   3              }
 187   2              // determine which state to go to next
 188   2              if(sector_offset == drive_values->SecPerClus)
 189   2              {
 190   3                //check if we hit the end of this cluster
 191   3                player_state = find_cluster_2;
 192   3              }
 193   2              else if((DATA_REQ_INACTIVE && (buffer1_flag==BUFFER_EMPTY))
 194   2                  || ((buffer1_flag==BUFFER_EMPTY) && (buffer1_flag==BUFFER_EMPTY)))
 195   2              {
 196   3                // if we're inactive and buffer1 is empty, go fill it
 197   3                // OR, if both buffers are empty, go fill buffer1
 198   3                player_state = load_buffer_1;
 199   3              }
 200   2              else if((buffer2_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 201   2              {
 202   3                // decoder wants data, but buffer2 was empty, so go check buffer1
 203   3                player_state = data_send_1;
 204   3              }
 205   2              else if(DATA_REQ_INACTIVE)
 206   2              {
 207   3                // if nothing else needs to be taken care of above, just go back to idle
 208   3                player_state = data_idle_2;
 209   3              }
 210   2            break;
 211   2          case song_end:
 212   2            // do nothing -- outside functions could watch for this and do something while we stay here
 213   2            LED_number(9);
 214   2            break;
 215   2        }
 216   1      
 217   1        if(player_state == song_end) return PLAYER_COMPLETE;
 218   1        return PLAYER_RUNNING;
 219   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    921    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
