C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 07:15:58 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE PLAYER
OBJECT MODULE PLACED IN .\player.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\player.c DEBUG OBJECTEXTEND PRINT(.\player.lst) OBJECT(.\player.o
                    -bj) 

stmt level    source

   1          #include "main.h"
   2          #include "SDCard.h"
   3          #include "PORT.h"
   4          #include "player.h"
   5          #include "Outputs.h"
   6          #include "file_system.h"
   7          #include "Directory_Functions_struct.h"
   8          #include "sector_reader.h"
   9          #include "SPI.h"
  10          #include "LED_Control.h"
  11          #include <stdio.h>
  12          
  13          #define BUF_SIZE (512)
  14          extern uint8_t xdata buf1[BUF_SIZE];
  15          extern uint8_t xdata buf2[BUF_SIZE];
  16          
  17          typedef enum {find_cluster_1, data_idle_1, load_buffer_1, data_send_1,
  18                        find_cluster_2, data_idle_2, load_buffer_2, data_send_2, song_end} player_state_t;
  19          player_state_t player_state;
  20          
  21          
  22          // might be active low
  23          #define DATA_REQ_ACTIVE   (DATA_REQ == 0)
  24          #define DATA_REQ_INACTIVE (DATA_REQ != 0)
  25          
  26          uint8_t buffer1_flag;
  27          uint8_t buffer2_flag;
  28          
  29          #define BUFFER_EMPTY (1)
  30          #define BUFFER_FULL  (0)
  31          
  32          uint16_t index1;
  33          uint16_t index2;
  34          
  35          
  36          uint32_t base_sector;
  37          uint32_t sector_offset;
  38          uint32_t current_cluster;
  39          static FS_values_t *drive_values;
  40          
  41          void load_sector(uint8_t *buf)
  42          {
  43   1        // check if we need to find the first sector of the cluster
  44   1        if(sector_offset == 0) base_sector = first_sector(current_cluster);
  45   1        // read the sector in
  46   1        Read_Sector((base_sector+sector_offset), drive_values->BytesPerSec, buf);
  47   1        sector_offset++; // go forward one sector
  48   1      }
  49          
  50          void init_player(uint32_t start_cluster)
  51          {
  52   1        player_state    = data_send_1;
  53   1        buffer1_flag    = BUFFER_FULL;
  54   1        buffer2_flag    = BUFFER_EMPTY;
C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 07:15:58 PAGE 2   

  55   1        index1          = 0;
  56   1        index2          = 0;
  57   1        drive_values    = Export_Drive_values();
  58   1        base_sector     = first_sector(start_cluster);
  59   1        sector_offset   = 0;
  60   1        current_cluster = start_cluster;
  61   1        load_sector(buf1);
  62   1        //while(player_state_machine_runner() == PLAYER_RUNNING);
  63   1      }
  64          
  65          // flush out as much as the decoder will take
  66          uint8_t send_buffer(uint8_t *buf, uint16_t *index, uint8_t *buffer_flag)
  67          {
  68   1        uint8_t temp8;
  69   1        P1_set_bit(STA_SPI_BIT_EN_bit);
  70   1        for(;((*index)<BUF_SIZE)&&(DATA_REQ_ACTIVE); (*index)++) SPI_Transfer(buf[(*index)], &temp8);
  71   1        P1_clear_bit(STA_SPI_BIT_EN_bit);
  72   1        // check if we flushed the entire buffer
  73   1        // if there's still more to go, then the state machine will know since the buffer didn't
  74   1        // get set empty and it can continue sending when it's ready again
  75   1        if((*index) == BUF_SIZE)
  76   1        {
  77   2          (*index)=0;
  78   2          (*buffer_flag)=BUFFER_EMPTY;
  79   2          return 1;
  80   2        }
  81   1        return 0;
  82   1      }
  83          
  84          uint8_t player_state_machine_runner(void)
  85          {
  86   1        switch(player_state)
  87   1        {
  88   2          case find_cluster_1:
  89   2            LED_number(1);
  90   2            current_cluster = find_next_clus(current_cluster, buf1);
  91   2            if(current_cluster != FAT_END_OF_FILE_MARKER)
  92   2            {
  93   3              sector_offset = 0;
  94   3              player_state = data_idle_2;
  95   3            }
  96   2            else
  97   2            {
  98   3              player_state = song_end;
  99   3            }
 100   2            break;
 101   2          case data_idle_1:
 102   2            LED_number(2);
 103   2            if(DATA_REQ_ACTIVE) player_state = data_send_1;
 104   2            break;
 105   2          case load_buffer_1:
 106   2            LED_number(3);
 107   2            // check if we hit the end of this cluster
 108   2            // if so, load the FAT sector into the open buffer, but don't indicate that it's
 109   2            // filled since it isn't data
 110   2            if(sector_offset == drive_values->SecPerClus)
 111   2            {
 112   3              player_state = find_cluster_1;
 113   3            }
 114   2            else
 115   2            {
 116   3              load_sector(buf1);
C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 07:15:58 PAGE 3   

 117   3              buffer1_flag = BUFFER_FULL;
 118   3              player_state = data_idle_2;
 119   3            }
 120   2            break;
 121   2          case data_send_1:
 122   2            LED_number(4);
 123   2            if(DATA_REQ_ACTIVE)
 124   2            {
 125   3              if(buffer1_flag == BUFFER_FULL) send_buffer(buf1, &index1, &buffer1_flag);
 126   3            }
 127   2      
 128   2            if((DATA_REQ_INACTIVE && (buffer2_flag==BUFFER_EMPTY))
 129   2                || ((buffer1_flag==BUFFER_EMPTY) && (buffer2_flag==BUFFER_EMPTY)))
 130   2            {
 131   3              // if we're inactive and buffer2 is empty, go fill it
 132   3              // OR, if both buffers are empty, go fill buffer2
 133   3              player_state = load_buffer_2;
 134   3            }
 135   2            else if((buffer1_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 136   2            {
 137   3              // decoder wants data, but buffer1 was empty, so go check buffer2
 138   3              player_state = data_send_2;
 139   3            }
 140   2            else if(DATA_REQ_INACTIVE)
 141   2            {
 142   3              // if nothing else needs to be taken care of above, just go back to idle
 143   3              player_state = data_idle_1;
 144   3            }
 145   2            break;
 146   2          case find_cluster_2:
 147   2            LED_number(5);
 148   2            current_cluster = find_next_clus(current_cluster, buf2);
 149   2            if(current_cluster != FAT_END_OF_FILE_MARKER)
 150   2            {
 151   3              sector_offset = 0;
 152   3              player_state = data_idle_1;
 153   3            }
 154   2            else
 155   2            {
 156   3              player_state = song_end;
 157   3            }
 158   2            break;
 159   2          case data_idle_2:
 160   2            LED_number(6);
 161   2            if(DATA_REQ_ACTIVE) player_state = data_send_2;
 162   2            break;
 163   2          case load_buffer_2:
 164   2            LED_number(7);
 165   2            // check if we hit the end of this cluster
 166   2            // if so, load the FAT sector into the open buffer, but don't indicate that it's
 167   2            // filled since it isn't data
 168   2            if(sector_offset == drive_values->SecPerClus)
 169   2            {
 170   3              //check if we hit the end of this cluster
 171   3              player_state = find_cluster_2;
 172   3            }
 173   2            else
 174   2            {
 175   3              load_sector(buf2);
 176   3              buffer2_flag = BUFFER_FULL;
 177   3              player_state = data_idle_1;
 178   3            }
C51 COMPILER V6.02  PLAYER                                                                 11/21/2019 07:15:58 PAGE 4   

 179   2            break;
 180   2          case data_send_2:
 181   2            LED_number(8);
 182   2            if(DATA_REQ_ACTIVE)
 183   2            {
 184   3              if(buffer2_flag == BUFFER_FULL) send_buffer(buf2, &index2, &buffer2_flag);
 185   3            }
 186   2      
 187   2            // determine which state to go to next
 188   2            if((DATA_REQ_INACTIVE && (buffer1_flag==BUFFER_EMPTY))
 189   2              || ((buffer1_flag==BUFFER_EMPTY) && (buffer2_flag==BUFFER_EMPTY)))
 190   2            {
 191   3              // if we're inactive and buffer1 is empty, go fill it
 192   3              // OR, if both buffers are empty, go fill buffer1
 193   3              player_state = load_buffer_1;
 194   3            }
 195   2            else if((buffer2_flag==BUFFER_EMPTY) && DATA_REQ_ACTIVE)
 196   2            {
 197   3              // decoder wants data, but buffer2 was empty, so go check buffer1
 198   3              player_state = data_send_1;
 199   3            }
 200   2            else if(DATA_REQ_INACTIVE)
 201   2            {
 202   3              // if nothing else needs to be taken care of above, just go back to idle
 203   3              player_state = data_idle_2;
 204   3            }
 205   2            break;
 206   2          case song_end:
 207   2            // do nothing -- outside functions could watch for this and do something while we stay here
 208   2            LED_number(9);
 209   2            break;
 210   2        }
 211   1      
 212   1        if(player_state == song_end) return PLAYER_COMPLETE;
 213   1        return PLAYER_RUNNING;
 214   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    825    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
