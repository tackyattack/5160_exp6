C51 COMPILER V6.02  SEOS                                                                   11/21/2019 06:07:41 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE SEOS
OBJECT MODULE PLACED IN .\sEOS.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\sEOS.c DEBUG OBJECTEXTEND PRINT(.\sEOS.lst) OBJECT(.\sEOS.obj) 

stmt level    source

   1          #include "sEOS.h"
   2          #include "Directory_Functions_struct.h"
   3          #include "UART.h"
   4          #include "file_system.h"
   5          #include "player.h"
   6          #include "LED_Control.h"
   7          #include <stdio.h>
   8          
   9          extern uint8_t xdata buf1[512];
  10          extern uint8_t xdata buf2[512];
  11          
  12          typedef enum {os_idle, print_buffer, recv_input, run_print_dir_task, run_read_dir_entry_task,
  13                        start_song, play_song_task} seos_state_t;
  14          seos_state_t seos_state;
  15          
  16          uint16_t temp16, cwd_entries;
  17          uint8_t temp8;
  18          uint32_t entry_num;
  19          uint32_t cwd, clus;
  20          uint8_t tens = 0;
  21          
  22          bit print_dir_task_running = 0;
  23          bit read_dir_entry_task_running = 0;
  24          
  25          void loop_tester()
  26          {
  27   1        switch(seos_state)
  28   1        {
  29   2          case os_idle:
  30   2            LED_number(1);
  31   2            temp8 = UART_Receive_Non_Blocking();
  32   2            if(temp8 != 0)
  33   2            {
  34   3              seos_state = recv_input;
  35   3            }
  36   2            if(print_dir_task_running) seos_state = run_print_dir_task;
  37   2            if(read_dir_entry_task_running) seos_state = run_read_dir_entry_task;
  38   2            if(get_directory_print_buffer_pos() > 0)
  39   2            {
  40   3              seos_state = print_buffer;
  41   3            }
  42   2            break;
  43   2          case recv_input:
  44   2            LED_number(2);
  45   2            if(temp8 == '\r')
  46   2            {
  47   3              if(entry_num <= cwd_entries)
  48   3              {
  49   4              read_dir_entry_init(entry_num, cwd);
  50   4              read_dir_entry_task_running = 1;
  51   4              }
  52   3              else
  53   3              {
  54   4                set_directory_print_buffer_pos
  55   4                (
C51 COMPILER V6.02  SEOS                                                                   11/21/2019 06:07:41 PAGE 2   

  56   4                  get_directory_print_buffer_pos()
  57   4                  + sprintf(get_directory_print_buffer()+get_directory_print_buffer_pos(), "\nError: invalid ent
             -ry choice. Try again:\n")
  58   4                );
  59   4              }
  60   3              tens = 0;
  61   3              seos_state = os_idle;
  62   3              entry_num = 0;
  63   3            }
  64   2            else if((temp8 >= '0') && (temp8 <= '9'))
  65   2            {
  66   3              putchar(temp8);
  67   3              entry_num = temp8-'0' + entry_num*10;
  68   3              seos_state = os_idle;
  69   3            }
  70   2            else
  71   2            {
  72   3              seos_state = os_idle;
  73   3            }
  74   2            break;
  75   2          case print_buffer:
  76   2            LED_number(3);
  77   2            putchar(get_directory_print_buffer()[temp16]);
  78   2            temp16++;
  79   2            if(temp16 > get_directory_print_buffer_pos())
  80   2            {
  81   3              set_directory_print_buffer_pos(0);
  82   3              temp16=0;
  83   3            }
  84   2            seos_state = os_idle;
  85   2            break;
  86   2          case run_print_dir_task:
  87   2            LED_number(4);
  88   2            if(print_directory_task(&cwd_entries) == TASK_RUNNING)
  89   2            {
  90   3              temp16 = 0;
  91   3              seos_state = print_buffer;
  92   3            }
  93   2            else
  94   2            {
  95   3              print_dir_task_running = 0;
  96   3              seos_state = print_buffer;
  97   3              set_directory_print_buffer_pos
  98   3              (
  99   3                get_directory_print_buffer_pos()
 100   3                + sprintf(get_directory_print_buffer()+get_directory_print_buffer_pos(), "\nEnter an entry numbe
             -r:\n")
 101   3              );
 102   3            }
 103   2            break;
 104   2          case run_read_dir_entry_task:
 105   2            LED_number(5);
 106   2            if(read_dir_entry_task(&clus) == TASK_RUNNING)
 107   2            {
 108   3              // go back to idle since we're still going
 109   3              seos_state = os_idle;
 110   3            }
 111   2            else
 112   2            {
 113   3              read_dir_entry_task_running = 0;
 114   3              if(clus & directory_bit)
 115   3              {
C51 COMPILER V6.02  SEOS                                                                   11/21/2019 06:07:41 PAGE 3   

 116   4                seos_state = os_idle;
 117   4                clus &= 0x0FFFFFFF; // mask off upper four bits to print another directory
 118   4                cwd = first_sector(clus);
 119   4                print_directory_init(cwd);
 120   4                print_dir_task_running=1;
 121   4              }
 122   3              else
 123   3              {
 124   4                seos_state = start_song;
 125   4              }
 126   3            }
 127   2            break;
 128   2          case start_song:
 129   2            LED_number(6);
 130   2            init_player(clus);
 131   2            seos_state = play_song_task;
 132   2            break;
 133   2          case play_song_task:
 134   2            LED_number(7);
 135   2            if(player_state_machine_runner() == PLAYER_RUNNING)
 136   2            {
 137   3              seos_state = play_song_task;
 138   3            }
 139   2            else
 140   2            {
 141   3              print_directory_init(cwd);
 142   3              print_dir_task_running=1;
 143   3              seos_state = os_idle;
 144   3            }
 145   2            break;
 146   2        }
 147   1      
 148   1      }
 149          
 150          // void sEOS_ISR(void) interrupt Timer_2_overflow using 1
 151          // {
 152          //   TF2 = 0; // clear timer flag that caused this interrupt
 153          // }
 154          //
 155          void sEOS_init(uint8_t interval_ms)
 156          {
 157   1           cwd = Export_Drive_values()->FirstRootDirSec; // start out at root directory
 158   1           print_directory_init(cwd);
 159   1           print_dir_task_running=1;
 160   1           entry_num = 0;
 161   1           seos_state = os_idle;
 162   1      
 163   1      //   T2CON=0;
 164   1      //   uint16_t PRELOAD=(65536â€“((OSC_FREQ*interval_ms)/(OSC_PER_INST*1000UL))));
 165   1      //   RCAP2H=(uint8_t)PRELOAD/256;
 166   1      //   RCAP2L=(uint8_t)PRELOAD%256;
 167   1      //   TF2=0; // Clear overflow
 168   1      //   ET2=1; // Enable Timer 2 interrupt
 169   1      //   EA=1;  // Set Global Interrupt Enable
 170   1      //   TR2=1; // Start Timer Running
 171   1      }
*** WARNING C280 IN LINE 155 OF ..\SOURCE\SEOS.C: 'interval_ms': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    602    ----
   CONSTANT SIZE    =     67    ----
C51 COMPILER V6.02  SEOS                                                                   11/21/2019 06:07:41 PAGE 4   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
