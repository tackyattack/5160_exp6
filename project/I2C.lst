C51 COMPILER V6.02  I2C                                                                    11/21/2019 16:42:11 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\I2C.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\I2C.c PRINT(.\I2C.lst) OBJECT(.\I2C.obj) 

stmt level    source

   1          #include "main.h"
   2          #include "PORT.H"
   3          #include "I2C.h"
   4          #include <stdio.h>
   5          
   6          /********************************************************************
   7          
   8          Private Function Declarations
   9          
  10          *********************************************************************/
  11          // #define I2C_FREQ (25000)
  12          // #define I2C_RELOAD (65536-((OSC_FREQ)/(OSC_PER_INST*I2C_FREQ*2UL)))
  13          #define I2C_FREQ (25000UL)
  14          #define I2C_RELOAD ((uint16_t)(65536-((OSC_FREQ)/(OSC_PER_INST*I2C_FREQ*2UL))))
  15          #define I2C_RELOAD_H (I2C_RELOAD/256)
  16          #define I2C_RELOAD_L (I2C_RELOAD%256)
  17          
  18          #define Continue (1)
  19          #define Stop (2)
  20          
  21          
  22          void I2C_clock_start(void);
  23          void I2C_clock_delay(uint8_t control);
  24          
  25          /***********************************************************************
  26          DESC:    Creates the signals required for transmitting bytes using
  27                   the I2C bus.
  28          RETURNS: Error Flag
  29          CAUTION:
  30          
  31          ************************************************************************/
  32          
  33          uint8_t I2C_Write(uint8_t device_addr,uint32_t int_addr, uint8_t int_addr_sz, uint8_t num_bytes,uint8_t * 
             -send_array)
  34          {
  35   1        uint8_t send_val, return_val, num_bits, send_bit, sent_bit;
  36   1      
  37   1        SDA=1;
  38   1        SCL=1;
  39   1        return_val=no_errors;
  40   1        int_addr_sz=int_addr_sz*8; // convert int_addr_sz from bytes to bits
  41   1        num_bytes++;  // Add the device address byte
  42   1        if((SCL==1) && (SDA==1))
  43   1        {
  44   2           I2C_clock_start();
  45   2           send_val=device_addr<<1;
  46   2      	 send_val&=0xFE;           // make sure lsb is 0 for write
  47   2      	 //  send START condition
  48   2      	 SDA=0;
  49   2      	 do
  50   2      	 {
  51   3      	    num_bits=8;
  52   3              do
  53   3      		{
  54   4      		   I2C_clock_delay(Continue);
C51 COMPILER V6.02  I2C                                                                    11/21/2019 16:42:11 PAGE 2   

  55   4      		   SCL=0;
  56   4      		   num_bits--;
  57   4                 send_bit=((send_val>>num_bits)&0x01);
  58   4      		   SDA=(bit)send_bit;
  59   4      		   I2C_clock_delay(Continue);
  60   4                 SCL=1;
  61   4      		   while(SCL!=1);
  62   4                 sent_bit=SDA;
  63   4      		   if(sent_bit!=send_bit) return_val=bus_busy_error;
  64   4               }while((num_bits>0)&&(return_val==no_errors));
  65   3               if(return_val==no_errors)
  66   3      		 {
  67   4      		    I2C_clock_delay(Continue);
  68   4      		    SCL=0;
  69   4                  SDA=1;      // set SDA high so slave can send ACK
  70   4      			if(int_addr_sz!=0)
  71   4      			{
  72   5      			    int_addr_sz=int_addr_sz-8;
  73   5      			    send_val=(int_addr>>int_addr_sz);
  74   5      			}
  75   4      			else
  76   4      			{
  77   5                      num_bytes--;
  78   5      		        send_val=*(send_array);
  79   5      		        send_array++;
  80   5      			}
  81   4      		    I2C_clock_delay(Continue);
  82   4      		    SCL=1;
  83   4      		    while(SCL!=1);
  84   4      		    sent_bit=SDA;
  85   4      		    if(sent_bit!=0) return_val=NACK_error;
  86   4                }
  87   3            }while((num_bytes!=0)&&(return_val==no_errors));
  88   2            // send STOP condition
  89   2            if(return_val!=bus_busy_error)
  90   2            {
  91   3      	     I2C_clock_delay(Continue);
  92   3               SCL=0;
  93   3      	     SDA=0;
  94   3      	     I2C_clock_delay(Continue);
  95   3      	     SCL=1;
  96   3      	     while(SCL!=1);
  97   3      	     I2C_clock_delay(Stop);
  98   3      	     SDA=1;
  99   3             }
 100   2        }
 101   1        else
 102   1        {
 103   2           return_val=bus_busy_error;
 104   2        }
 105   1        return return_val;
 106   1      }
 107          
 108          /***********************************************************************
 109          DESC:    Creates the signals required for receiving bytes using
 110                   the I2C bus.
 111          RETURNS: Error Flag
 112          CAUTION:
 113          
 114          ************************************************************************/
 115          
 116          
C51 COMPILER V6.02  I2C                                                                    11/21/2019 16:42:11 PAGE 3   

 117          uint8_t I2C_Read(uint8_t device_addr,uint32_t int_addr, uint8_t int_addr_sz, uint8_t num_bytes,uint8_t * r
             -ec_array)
 118          {
 119   1        uint8_t send_val, return_val, num_bits, send_bit, sent_bit,rcv_val;
 120   1      
 121   1        return_val=no_errors;
 122   1        /*** If there is an internal address, use I2C_Write to send that address first with no data bytes writte
             -n ****/
 123   1        if(int_addr_sz!=0)
 124   1        {
 125   2           return_val=I2C_Write(device_addr,int_addr,int_addr_sz,0,rec_array);
 126   2        }
 127   1        if(return_val==no_errors)
 128   1        {
 129   2        SDA=1;
 130   2        SCL=1;
 131   2        if((SCL==1) && (SDA==1))
 132   2        {
 133   3           I2C_clock_start();
 134   3           send_val=device_addr<<1;
 135   3      	 send_val|=0x01;           // make sure lsb is 1 for read
 136   3      	 //  send START condition
 137   3      	 SDA=0;
 138   3      	 //  send device address+R
 139   3      	 num_bits=8;
 140   3           do
 141   3      	 {
 142   4      		I2C_clock_delay(Continue);
 143   4      	    SCL=0;
 144   4      		num_bits--;
 145   4              send_bit=((send_val>>num_bits)&0x01);
 146   4      		SDA=(bit)send_bit;
 147   4      		I2C_clock_delay(Continue);
 148   4              SCL=1;
 149   4      		while(SCL!=1);
 150   4              sent_bit=SDA;
 151   4      		if(sent_bit!=send_bit) return_val=bus_busy_error;
 152   4            }while((num_bits>0)&&(return_val==no_errors));
 153   3            if(return_val==no_errors)
 154   3            {
 155   4      	     I2C_clock_delay(Continue);
 156   4      	     SCL=0;
 157   4               SDA=1;      // set SDA high so slave can send ACK
 158   4      	     I2C_clock_delay(Continue);
 159   4      	     SCL=1;
 160   4      	     while(SCL!=1);
 161   4      	     sent_bit=SDA;
 162   4      	     if(sent_bit!=0) return_val=NACK_error;
 163   4            }
 164   3            while((num_bytes>0)&&(return_val==no_errors))
 165   3      	  {
 166   4      	     num_bits=8;
 167   4      	     do
 168   4      		 {
 169   5      		   I2C_clock_delay(Continue);
 170   5      		   SCL=0;
 171   5      		   num_bits--;
 172   5      		   SDA=1;
 173   5      		   rcv_val=rcv_val<<1;  // shift value to prepare for next rcvd bit
 174   5      		   I2C_clock_delay(Continue);
 175   5      		   SCL=1;
 176   5      		   while(SCL!=1);
C51 COMPILER V6.02  I2C                                                                    11/21/2019 16:42:11 PAGE 4   

 177   5                 sent_bit=SDA;
 178   5      		   rcv_val|=sent_bit;
 179   5      		 }while(num_bits>0);
 180   4      		 *rec_array=rcv_val;
 181   4      		 rec_array++;
 182   4      		 if(num_bytes==1)
 183   4      		 {
 184   5      		    send_bit=1;   // NACK for last byte
 185   5      		 }
 186   4      		 else
 187   4      		 {
 188   5      		    send_bit=0;   // ACK if more bytes are to be received
 189   5      		 }
 190   4      		 I2C_clock_delay(Continue);
 191   4      		 SCL=0;
 192   4      		 SDA=send_bit;
 193   4      		 I2C_clock_delay(Continue);
 194   4      		 SCL=1;
 195   4      		 while(SCL!=1);
 196   4      		 num_bytes--;
 197   4      	  }
 198   3            // send STOP condition
 199   3            if(return_val!=bus_busy_error)
 200   3            {
 201   4      	     I2C_clock_delay(Continue);
 202   4               SCL=0;
 203   4      	     SDA=0;
 204   4      	     I2C_clock_delay(Continue);
 205   4      	     SCL=1;
 206   4      	     while(SCL!=1);
 207   4      	     I2C_clock_delay(Stop);
 208   4      	     SDA=1;
 209   4             }
 210   3        }
 211   2        else
 212   2        {
 213   3           return_val=bus_busy_error;
 214   3        }
 215   2        }
 216   1        return return_val;
 217   1      }
 218          
 219          /***********************************************************************
 220          DESC:    Initializes and starts Timer0 for a hardware delay for
 221                   creating a consistant I2C frequency
 222          RETURNS: nothing
 223          CAUTION:
 224          
 225          ************************************************************************/
 226          
 227          void I2C_clock_start(void)
 228          {
 229   1      // Configure Timer0 as a 16-bit timer (mode1)
 230   1         TMOD &=0xF0;
 231   1         TMOD |=0x01;
 232   1      
 233   1         ET0=0;  //interrupts not used
 234   1      
 235   1         TH0=I2C_RELOAD_H;
 236   1         TL0=I2C_RELOAD_L;
 237   1      
 238   1         TF0=0;   // Clear overflow
C51 COMPILER V6.02  I2C                                                                    11/21/2019 16:42:11 PAGE 5   

 239   1         TR0=1;   // Start Timer Running
 240   1      }
 241          
 242          
 243          /***********************************************************************
 244          DESC:    Waits for the overflow to be set and restarts Timer0 for a
 245                   hardware delay for creating a consistant I2C frequency
 246          		 Timer is stopped if stop is sent.
 247          RETURNS: nothing
 248          CAUTION:
 249          
 250          ************************************************************************/
 251          
 252          void I2C_clock_delay(uint8_t control)
 253          {
 254   1         if(TR0==1)
 255   1         {
 256   2           while(TF0==0);
 257   2         }
 258   1      
 259   1         TR0=0;
 260   1         if(control==Continue)
 261   1         {
 262   2            TH0=I2C_RELOAD_H;
 263   2            TL0=I2C_RELOAD_L;
 264   2      
 265   2            TF0=0;   // Clear overflow
 266   2            TR0=1;   // Start Timer Running
 267   2         }
 268   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    611    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      31
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
