C51 COMPILER V6.02  FILE_SYSTEM                                                            11/21/2019 13:16:06 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE FILE_SYSTEM
OBJECT MODULE PLACED IN .\file_system.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\file_system.c LARGE DEBUG OBJECTEXTEND PRINT(.\file_system.lst) O
                    -BJECT(.\file_system.obj) 

stmt level    source

   1          #include <stdio.h>
   2          #include "main.h"
   3          #include "sector_reader.h"
   4          #include "Directory_Functions_struct.h"
   5          #include "UART.h"
   6          #include "SPI.h"
   7          #include "print_bytes.h"
   8          #include "file_system.h"
   9          
  10          // Private constants (outside doesn't need to see these)
  11          #define MBR_BPB_sec_offset              (0x01C6)
  12          #define BPB_BytesPerSector_offset       (0x000B)
  13          #define BPB_SectorsPerCluster_offset    (0x000D)
  14          #define BPB_RsvdSectorCount_offset      (0x000E)
  15          #define BPB_NumberFATs_offset           (0x0010)
  16          #define BPB_RootEntryCount_offset       (0x0011)
  17          #define BPB_TotSec16_offset             (0x0013)
  18          #define BPB_FATSz16_offset              (0x0016)
  19          #define BPB_FATSz32_offset              (0x0024)
  20          #define BPB_TotSec32_offset             (0x0020)
  21          #define BPB_RootClus_offset             (0x002C)
  22          
  23          FS_values_t *drive_values_m;
  24          
  25          uint8_t mount_drive(uint8_t xdata *xram_data_array)
  26          {
  27   1        uint8_t temp8, NumFAT;
  28   1        uint16_t temp16, RootEntCnt, RsvdSecCnt, FATSz16, TotSec16;
  29   1        uint32_t ClusterCount, FATSz, TotSec, DataSec, MBR_RelSec, RootClus;
  30   1        uint8_t *data_array;
  31   1        FS_values_t *drive_values_m;
  32   1        data_array = xram_data_array; // cast xdata to uint8_t since all other functions don't use xdata
  33   1      
  34   1        drive_values_m = Export_Drive_values();
  35   1      
  36   1      
  37   1        // Find the BIOS parameter block (BPB)
  38   1        printf("Finding BIOS parameter block\n");
  39   1        Read_Sector(0, 512, data_array);
  40   1        temp8 = read8(0, data_array); // check first byte
  41   1        MBR_RelSec = 0;
  42   1        if((temp8!=0xEB) && (temp8!=0xE9))
  43   1        {
  44   2          // likely MBR
  45   2          // If we're in the MBR, then get the offset for the BPB
  46   2          MBR_RelSec = read32(MBR_BPB_sec_offset, data_array);
  47   2          // now read the start of BPB
  48   2          Read_Sector(MBR_RelSec, 512, data_array);
  49   2          temp8 = read8(0, data_array);
  50   2        }
  51   1      
  52   1        // now check if we've made it into the BPB by checking for the jump instruction
  53   1        if((temp8!=0xEB) && (temp8!=0xE9))
  54   1        {
C51 COMPILER V6.02  FILE_SYSTEM                                                            11/21/2019 13:16:06 PAGE 2   

  55   2          printf("error: could not locate BPB\n");
  56   2          return MOUNT_FAIL;
  57   2        }
  58   1      
  59   1      
  60   1        // ------- Read in BIOS parameter block -------
  61   1        drive_values_m->BytesPerSec = read16(BPB_BytesPerSector_offset, data_array);
  62   1      
  63   1        // set shift value (used by print directory function)
  64   1        drive_values_m->BytesPerSecShift = 0;
  65   1      
  66   1        temp16 = drive_values_m->BytesPerSec;
  67   1        // shift right by one bit position until we've moved it all the way out
  68   1        while(temp16 != 0x01)
  69   1        {
  70   2           drive_values_m->BytesPerSecShift++;
  71   2           temp16 = temp16>>1;
  72   2        }
  73   1      
  74   1        drive_values_m->SecPerClus  = read8(BPB_SectorsPerCluster_offset, data_array);
  75   1      
  76   1        RsvdSecCnt  = read16(BPB_RsvdSectorCount_offset, data_array);
  77   1        NumFAT      = read8(BPB_NumberFATs_offset, data_array);
  78   1        RootEntCnt  = read16(BPB_RootEntryCount_offset, data_array);
  79   1        FATSz16     = read16(BPB_FATSz16_offset, data_array);
  80   1        TotSec16    = read16(BPB_TotSec16_offset, data_array);
  81   1        RootClus    = read32(BPB_RootClus_offset, data_array);
  82   1      
  83   1      
  84   1        if(FATSz16 != 0)
  85   1        {
  86   2          FATSz = read16(BPB_FATSz16_offset, data_array);
  87   2        }
  88   1        else
  89   1        {
  90   2          FATSz = read32(BPB_FATSz32_offset, data_array);
  91   2        }
  92   1      
  93   1        if(TotSec16 != 0)
  94   1        {
  95   2          TotSec = TotSec16;
  96   2        }
  97   1        else
  98   1        {
  99   2          TotSec = read32(BPB_TotSec32_offset, data_array);
 100   2        }
 101   1      
 102   1        // Determine how many sectors are in the root directory
 103   1        drive_values_m->RootDirSecs = ((RootEntCnt * 32) + (drive_values_m->BytesPerSec - 1)) / (drive_values_m-
             ->BytesPerSec);
 104   1      
 105   1        // Determine how many sectors are data sectors
 106   1        DataSec = TotSec - (RsvdSecCnt + (NumFAT*FATSz) + drive_values_m->RootDirSecs);
 107   1      
 108   1        // Determine first sector of FAT
 109   1        drive_values_m->StartofFAT = RsvdSecCnt + MBR_RelSec;
 110   1      
 111   1        // Determine the first sector of the data area
 112   1        drive_values_m->FirstDataSec = drive_values_m->StartofFAT + (NumFAT*FATSz) + drive_values_m->RootDirSecs
             -;
 113   1      
 114   1        // Determine count of clusters and FAT type
C51 COMPILER V6.02  FILE_SYSTEM                                                            11/21/2019 13:16:06 PAGE 3   

 115   1        ClusterCount = DataSec / drive_values_m->SecPerClus;
 116   1        if(ClusterCount < 4085)
 117   1        {
 118   2          // FAT12
 119   2          printf("error: FAT12 unsupported\n");
 120   2          return MOUNT_FAIL;
 121   2        }
 122   1        else if(ClusterCount < 65525)
 123   1        {
 124   2          // FAT16
 125   2          drive_values_m->FATtype = FAT16;
 126   2          printf("FAT16 detected\n");
 127   2          drive_values_m->FirstRootDirSec = drive_values_m->StartofFAT + (NumFAT*FATSz);
 128   2        }
 129   1        else
 130   1        {
 131   2          // FAT32
 132   2          drive_values_m->FATtype = FAT32;
 133   2          printf("FAT32 detected\n");
 134   2          drive_values_m->FirstRootDirSec = ((RootClus-2)*drive_values_m->SecPerClus) + drive_values_m->FirstDat
             -aSec;
 135   2        }
 136   1      
 137   1        return MOUNT_SUCCESS;
 138   1      }
 139          
 140          uint32_t first_sector(uint32_t cluster_num)
 141          {
 142   1        // Calculate starting sector of cluster
 143   1        if(cluster_num == 0)
 144   1        {
 145   2          return drive_values_m->FirstRootDirSec;
 146   2        }
 147   1        else
 148   1        {
 149   2          return ((cluster_num - 2)*drive_values_m->SecPerClus) + drive_values_m->FirstDataSec;
 150   2        }
 151   1      }
 152          
 153          
 154          uint32_t first_sector_i(uint32_t cluster_num)
 155          {
 156   1        // Calculate starting sector of cluster
 157   1        if(cluster_num == 0)
 158   1        {
 159   2          return drive_values_m->FirstRootDirSec;
 160   2        }
 161   1        else
 162   1        {
 163   2          return ((cluster_num - 2)*drive_values_m->SecPerClus) + drive_values_m->FirstDataSec;
 164   2        }
 165   1      }
 166          
 167          // uint32_t find_next_clus(uint32_t cluster_num, uint8_t xdata *xram_data_array)
 168          // {
 169          //   uint8_t *data_array;
 170          //   uint16_t FAToffset;
 171          //   uint32_t sector, next_clus;
 172          //   FS_values_t *drive_values_m = Export_Drive_values();
 173          //
 174          //   data_array = xram_data_array; // cast xdata to uint8_t since all other functions don't use xdata
 175          //
C51 COMPILER V6.02  FILE_SYSTEM                                                            11/21/2019 13:16:06 PAGE 4   

 176          //   // FATtype will be either 2 (FAT16) or 4 (FAT32)
 177          //   sector = ((cluster_num*drive_values_m->FATtype)/drive_values_m->BytesPerSec) + drive_values_m->Starto
             -fFAT;
 178          //   Read_Sector(sector, drive_values_m->BytesPerSec, data_array);
 179          //
 180          //   // Determine the offset of the cluster within this sector
 181          //   FAToffset = (uint16_t)((cluster_num*drive_values_m->FATtype)%(drive_values_m->BytesPerSec));
 182          //
 183          //   // Read the cluster entry from the FAT sector
 184          //   if(drive_values_m->FATtype == FAT32)
 185          //   {
 186          //     return (read32(FAToffset, data_array)&0x0FFFFFFF);
 187          //   }
 188          //   else if(drive_values_m->FATtype == FAT16)
 189          //   {
 190          //     next_clus = (uint32_t)(read16(FAToffset, data_array)&0xFFFF);
 191          //
 192          //     // modify EOF to match for FAT32
 193          //     if(next_clus == 0xFFFF)
 194          //     {
 195          //       return 0x0FFFFFFF;
 196          //     }
 197          //     else
 198          //     {
 199          //       return next_clus;
 200          //     }
 201          //   }
 202          //   else
 203          //   {
 204          //     printf("Error: FAT type unsupported\n");
 205          //     return 0;
 206          //   }
 207          //
 208          //   printf("Error: couldn't find next cluster\n");
 209          //   return 0;
 210          // }
 211          
 212          
 213          uint32_t find_next_clus_i(uint32_t cluster_num, uint8_t xdata *xram_data_array)
 214          {
 215   1        uint8_t *data_array;
 216   1         uint16_t FAToffset;
 217   1        uint32_t sector, next_clus;
 218   1        data_array = xram_data_array; // cast xdata to uint8_t since all other functions don't use xdata
 219   1        //
 220   1        // //FATtype will be either 2 (FAT16) or 4 (FAT32)
 221   1        sector = ((cluster_num*drive_values_m->FATtype)/drive_values_m->BytesPerSec) + drive_values_m->StartofFA
             -T;
 222   1        Read_Sector_i(sector, drive_values_m->BytesPerSec, data_array);
 223   1      
 224   1        // Determine the offset of the cluster within this sector
 225   1        FAToffset = (uint16_t)((cluster_num*drive_values_m->FATtype)%(drive_values_m->BytesPerSec));
 226   1      
 227   1        // Read the cluster entry from the FAT sector
 228   1        if(drive_values_m->FATtype == FAT32)
 229   1        {
 230   2          return (read32_i(FAToffset, data_array)&0x0FFFFFFF);
 231   2        }
 232   1        else if(drive_values_m->FATtype == FAT16)
 233   1        {
 234   2          next_clus = (uint32_t)(read16_i(FAToffset, data_array)&0xFFFF);
 235   2      
C51 COMPILER V6.02  FILE_SYSTEM                                                            11/21/2019 13:16:06 PAGE 5   

 236   2          // modify EOF to match for FAT32
 237   2          if(next_clus == 0xFFFF)
 238   2          {
 239   3            return 0x0FFFFFFF;
 240   3          }
 241   2          else
 242   2          {
 243   3            return next_clus;
 244   3          }
 245   2        }
 246   1        else
 247   1        {
 248   2          return 0;
 249   2        }
 250   1        return 0;
 251   1      }
 252          
 253          
 254          // void print_file(uint32_t cluster_num, uint8_t xdata *xram_data_array)
 255          // {
 256          //    uint32_t base_sector, sector_offset;
 257          //    uint8_t temp8;
 258          //    uint8_t *data_array;
 259          //    FS_values_t *drive_values_m = Export_Drive_values();
 260          //    data_array = xram_data_array; // cast xdata to uint8_t since all other functions don't use xdata
 261          //
 262          //    sector_offset = 0; // start at first sector
 263          //
 264          //    printf(" **** Opening File ****\n");
 265          //    printf("Press 'e' to exit\n");
 266          //    printf("Press 'n' to print nextn sector\n");
 267          //
 268          //    do
 269          //    {
 270          //       // check if we need to find the first sector of the cluster
 271          //       if(sector_offset == 0) base_sector = first_sector(cluster_num);
 272          //
 273          //       // read the sector in
 274          //       Read_Sector((base_sector+sector_offset), drive_values_m->BytesPerSec, data_array);
 275          //
 276          //
 277          //       printf(" **** cluster: %lu   sector: %lu ****\n", cluster_num, base_sector+sector_offset);
 278          //       print_memory(data_array, drive_values_m->BytesPerSec);
 279          //
 280          //       sector_offset++; // go forward one sector
 281          //
 282          //       // check if we need to go to the next cluster
 283          //       if(sector_offset == drive_values_m->SecPerClus)
 284          //       {
 285          //         cluster_num = find_next_clus(cluster_num, data_array);
 286          //         sector_offset = 0;
 287          //       }
 288          //
 289          //       // wait for user to choose an action
 290          //       do
 291          //       {
 292          //         temp8 = getchar();
 293          //       }while((temp8!='e') && (temp8!='n'));
 294          //
 295          //    }while(temp8 != 'e');
 296          // }

C51 COMPILER V6.02  FILE_SYSTEM                                                            11/21/2019 13:16:06 PAGE 6   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2070    ----
   CONSTANT SIZE    =    117    ----
   XDATA SIZE       =      3      63
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
