C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE DIRECTORY_FUNCTIONS_STRUCT
OBJECT MODULE PLACED IN .\Directory_Functions_struct.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\Directory_Functions_struct.c LARGE DEBUG OBJECTEXTEND PRINT(.\Dir
                    -ectory_Functions_struct.lst) OBJECT(.\Directory_Functions_struct.obj) 

stmt level    source

   1          #include "AT89C51RC2.h"
   2          //#include <stdio.h>
   3          #include "main.h"
   4          #include "PORT.H"
   5          #include "UART.h"
   6          #include "SPI.h"
   7          #include "SDCard.h"
   8          #include "File_System.h"
   9          #include "print_bytes.h"
  10          #include "Directory_Functions_struct.h"
  11          #include "sector_reader.h"
  12          
  13          
  14          
  15          FS_values_t idata Drive_values;
  16          
  17          // use one of the buffers to store our sectors
  18          extern uint8_t xdata buf1[512];
  19          // use the other as a print buffer
  20          extern uint8_t xdata buf2[512];
  21          // how many bytes are in our print buffer
  22          uint16_t idata print_buffer_pos = 0;
  23          
  24          
  25          // --------- data pool ---------
  26          // Note: since we're using a pool, only one task can be running at a time
  27          uint32_t idata *pool32;
  28          uint16_t idata *pool16;
  29          uint8_t  idata *pool8;
  30          
  31          void set_data_pool_dir(uint32_t *p32, uint16_t *p16, uint8_t *p8)
  32          {
  33   1        pool32 = p32;
  34   1        pool16 = p16;
  35   1        pool8  = p8;
  36   1      }
  37          
  38          typedef struct
  39          {
  40            uint32_t *Sector;
  41            uint32_t *Sector_num;
  42            uint32_t *max_sectors;
  43            uint16_t *i;
  44            uint16_t *entries;
  45            uint8_t *j;
  46            uint8_t *attr;
  47            uint8_t *out_val;
  48            uint8_t *error_flag;
  49          } print_directory_task_context_t;
  50          
  51          typedef struct
  52          {
  53            uint32_t *Sector;
  54            uint32_t *return_clus;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 2   

  55            uint32_t *Sector_num;
  56            uint32_t *max_sectors;
  57            uint16_t *i;
  58            uint16_t *entries;
  59            uint16_t *entry;
  60            uint8_t *j;
  61            uint8_t *attr;
  62            uint8_t *out_val;
  63            uint8_t *error_flag;
  64          } read_dir_entry_task_context_t;
  65          // -----------------------------
  66          
  67          void get_print_directory_task_context(print_directory_task_context_t *context)
  68          {
  69   1        context->Sector      = pool32 + 0;
  70   1        context->Sector_num  = pool32 + 1;
  71   1        context->max_sectors = pool32 + 2;
  72   1      
  73   1        context->i           = pool16 + 0;
  74   1        context->entries     = pool16 + 1;
  75   1      
  76   1        context->j           = pool8 + 0;
  77   1        context->attr        = pool8 + 1;
  78   1        context->out_val     = pool8 + 2;
  79   1        context->error_flag  = pool8 + 3;
  80   1      }
  81          
  82          void get_read_dir_entry_task_context(read_dir_entry_task_context_t *context)
  83          {
  84   1        context->Sector      = pool32 + 0;
  85   1        context->return_clus = pool32 + 1;
  86   1        context->max_sectors = pool32 + 2;
  87   1        context->Sector_num  = pool32 + 3;
  88   1      
  89   1        context->i           = pool16 + 0;
  90   1        context->entries     = pool16 + 1;
  91   1        context->entry       = pool16 + 2;
  92   1      
  93   1        context->j           = pool8 + 0;
  94   1        context->attr        = pool8 + 1;
  95   1        context->out_val     = pool8 + 2;
  96   1        context->error_flag  = pool8 + 3;
  97   1      }
  98          
  99          uint16_t get_directory_print_buffer_pos(void)
 100          {
 101   1        return print_buffer_pos;
 102   1      }
 103          
 104          void set_directory_print_buffer_pos(uint16_t pos)
 105          {
 106   1        print_buffer_pos = pos;
 107   1      }
 108          
 109          uint8_t *get_directory_print_buffer(void)
 110          {
 111   1        return buf2;
 112   1      }
 113          
 114          void print_directory_init(uint32_t sector_number_in)
 115          {
 116   1        print_directory_task_context_t context;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 3   

 117   1        get_print_directory_task_context(&context);
 118   1      
 119   1        *context.entries=0;
 120   1        *context.i=0;
 121   1        if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 122   1        {
 123   2          *context.max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 124   2        }
 125   1        else
 126   1        {
 127   2           *context.max_sectors=Drive_values.SecPerClus;
 128   2        }
 129   1        *context.Sector=sector_number_in;
 130   1        *context.Sector_num=sector_number_in;
 131   1        *context.error_flag=Read_Sector_i(*context.Sector,Drive_values.BytesPerSec,buf1);
 132   1      }
 133          
 134          void read_dir_entry_init(uint16_t entry_in, uint32_t sector_number_in)
 135          {
 136   1        read_dir_entry_task_context_t context;
 137   1        get_read_dir_entry_task_context(&context);
 138   1      
 139   1        *context.entries=0;
 140   1        *context.i=0;
 141   1        *context.return_clus=0;
 142   1        if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 143   1        {
 144   2           *context.max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 145   2        }
 146   1        else
 147   1        {
 148   2           *context.max_sectors=Drive_values.SecPerClus;
 149   2        }
 150   1        *context.Sector=sector_number_in;
 151   1        *context.Sector_num=sector_number_in;
 152   1        *context.entry=entry_in;
 153   1        *context.error_flag=Read_Sector_i(*context.Sector,Drive_values.BytesPerSec,buf1);
 154   1      }
 155          
 156          
 157          uint8_t print_directory_task(uint16_t *entries_in)
 158          {
 159   1        uint8_t temp8;
 160   1        print_directory_task_context_t context;
 161   1        uint8_t *values = buf1;
 162   1        get_print_directory_task_context(&context);
 163   1      
 164   1        temp8=read8_i(0 + (*context.i),values);  // read first byte to see if empty
 165   1        if((temp8!=0xE5)&&(temp8!=0x00))
 166   1        {
 167   2          *context.attr=read8_i(0x0b+ (*context.i),values);
 168   2          if(((*context.attr) & 0x0E)==0)   // if hidden, system or Vol_ID bit is set do not print
 169   2          {
 170   3            (*context.entries)++;
 171   3            //print_buffer_pos += sprintf(buf2+print_buffer_pos, "%5d. ", *context.entries);  // print entry num
             -ber with a fixed width specifier
 172   3            for(*context.j=0;*context.j<8;(*context.j)++)
 173   3            {
 174   4              *context.out_val=read8_i((*context.i)+(*context.j),values);   // print the 8 byte name
 175   4              //print_buffer_pos += sprintf(buf2+print_buffer_pos, "%c", *context.out_val);
 176   4            }
 177   3            if(((*context.attr)&0x10)==0x10)  // indicates directory
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 4   

 178   3            {
 179   4              for(*context.j=8;*context.j<11;(*context.j)++)
 180   4              {
 181   5                *context.out_val=read8_i((*context.i)+(*context.j),values);
 182   5                //print_buffer_pos += sprintf(buf2+print_buffer_pos, "%c", *context.out_val);
 183   5              }
 184   4              //print_buffer_pos += sprintf(buf2+print_buffer_pos, "[DIR]\n");
 185   4            }
 186   3            else       // print a period and the three byte extension for a file
 187   3            {
 188   4              //print_buffer_pos += sprintf(buf2+print_buffer_pos, ".", *context.out_val);
 189   4              for(*context.j=8;*context.j<11;(*context.j)++)
 190   4              {
 191   5                *context.out_val=read8_i((*context.i) + (*context.j),values);
 192   5                //print_buffer_pos += sprintf(buf2+print_buffer_pos, "%c", *context.out_val);
 193   5              }
 194   4              //print_buffer_pos += sprintf(buf2+print_buffer_pos, "\r\n", *context.out_val);
 195   4            }
 196   3          }
 197   2        }
 198   1        *context.i=(*context.i)+32;  // next entry
 199   1        if(*context.i>510)
 200   1        {
 201   2          (*context.Sector)++;
 202   2          if(((*context.Sector)-(*context.Sector_num))<*context.max_sectors)
 203   2          {
 204   3            *context.error_flag=Read_Sector_i(*context.Sector,Drive_values.BytesPerSec,buf1);
 205   3            if(*context.error_flag!=no_errors)
 206   3            {
 207   4              *context.entries=0;   // no entries found indicates disk read error
 208   4              temp8=0;     // forces a function exit
 209   4            }
 210   3            *context.i=0;
 211   3          }
 212   2          else
 213   2          {
 214   3            *context.entries=(*context.entries)|more_entries;  // set msb to indicate more entries in another cl
             -uster
 215   3            temp8=0;                       // forces a function exit
 216   3          }
 217   2        }
 218   1        if(temp8==0)
 219   1        {
 220   2          *entries_in = *context.entries;
 221   2          return TASK_COMPLETE;
 222   2        }
 223   1        return TASK_RUNNING;
 224   1      }
 225          
 226          uint8_t read_dir_entry_task(uint32_t *cluster)
 227          {
 228   1        read_dir_entry_task_context_t context;
 229   1        uint8_t temp8;
 230   1        uint8_t *values = buf1;
 231   1        get_read_dir_entry_task_context(&context);
 232   1      
 233   1        temp8=read8_i(0 + (*context.i),values);  // read first byte to see if empty
 234   1        if((temp8!=0xE5)&&(temp8!=0x00))
 235   1        {
 236   2          *context.attr=read8_i(0x0b + (*context.i), values);
 237   2          if(((*context.attr)&0x0E)==0)    // if hidden do not print
 238   2          {
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 5   

 239   3            (*context.entries)++;
 240   3            if(*context.entries==*context.entry)
 241   3            {
 242   4              if(Drive_values.FATtype==FAT32)
 243   4              {
 244   5                *context.return_clus=read8_i(21 + (*context.i),values);
 245   5                *context.return_clus=(*context.return_clus)<<8;
 246   5                *context.return_clus|=read8_i(20 + (*context.i),values);
 247   5                *context.return_clus=(*context.return_clus)<<8;
 248   5              }
 249   4              *context.return_clus|=read8_i(27+ (*context.i),values);
 250   4              *context.return_clus=(*context.return_clus)<<8;
 251   4              *context.return_clus|=read8_i(26 + (*context.i),values);
 252   4              *context.attr=read8_i(0x0b + (*context.i),values);
 253   4              if((*context.attr)&0x10) (*context.return_clus)= (*context.return_clus) | directory_bit;
 254   4              temp8=0;    // forces a function exit
 255   4            }
 256   3      
 257   3          }
 258   2        }
 259   1        *context.i= (*context.i)+32;  // next entry
 260   1        if((*context.i)>510)
 261   1        {
 262   2          (*context.Sector)++;
 263   2          if(((*context.Sector)-(*context.Sector_num))<(*context.max_sectors))
 264   2          {
 265   3            *context.error_flag=Read_Sector_i(*context.Sector,Drive_values.BytesPerSec,values);
 266   3            if(*context.error_flag!=no_errors)
 267   3            {
 268   4              *context.return_clus=no_entry_found;
 269   4              temp8=0;
 270   4            }
 271   3            *context.i=0;
 272   3          }
 273   2          else
 274   2          {
 275   3            temp8=0;                       // forces a function exit
 276   3          }
 277   2        }
 278   1      
 279   1        if(temp8 != 0)
 280   1        {
 281   2          return TASK_RUNNING;
 282   2        }
 283   1      
 284   1        if(*context.return_clus==0)
 285   1        {
 286   2          *cluster=no_entry_found;
 287   2        }
 288   1        else
 289   1        {
 290   2          *cluster=*context.return_clus;
 291   2        }
 292   1      
 293   1        return TASK_COMPLETE;
 294   1       }
 295          
 296          
 297          /***********************************************************************
 298          DESC: Returns a pointer to the global structure Drive_values to export to other files
 299          INPUT: void
 300          RETURNS: Pointer to the structure Drive_values
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 6   

 301          CAUTION:
 302          ************************************************************************/
 303          
 304          FS_values_t * Export_Drive_values(void)
 305          {
 306   1         return &Drive_values;
 307   1      }
 308          
 309          
 310          /***********************************************************************
 311          DESC: Prints all short file name entries for a given directory
 312          INPUT: Starting Sector of the directory and the pointer to a
 313          block of memory in xdata that can be used to read blocks from the SD card
 314          RETURNS: uint16_t number of entries found in the directory
 315          CAUTION: Supports FAT16, SD_shift must be set before using this function
 316          ************************************************************************/
 317          
 318          
 319          
 320          // uint16_t  Print_Directory(uint32_t Sector_num, uint8_t xdata * array_in)
 321          // {
 322          //    uint32_t Sector, max_sectors;
 323          //    uint16_t i, entries;
 324          //    uint8_t temp8, j, attr, out_val, error_flag;
 325          //    uint8_t * values;
 326          //
 327          //
 328          //    values=array_in;
 329          //    entries=0;
 330          //    i=0;
 331          //    if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 332          //    {
 333          //       max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 334          //    }
 335          //    else
 336          //    {
 337          //       max_sectors=Drive_values.SecPerClus;
 338          //    }
 339          //    Sector=Sector_num;
 340          //    error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 341          //    if(error_flag==no_errors)
 342          //    {
 343          //      do
 344          //      {
 345          //         temp8=read8_i(0+i,values);  // read first byte to see if empty
 346          //         if((temp8!=0xE5)&&(temp8!=0x00))
 347          // 	    {
 348          // 	       attr=read8_i(0x0b+i,values);
 349          // 		   if((attr&0x0E)==0)   // if hidden, system or Vol_ID bit is set do not print
 350          // 		   {
 351          // 		      entries++;
 352          // 			  printf("%5d. ",entries);  // print entry number with a fixed width specifier
 353          // 		      for(j=0;j<8;j++)
 354          // 			  {
 355          // 			     out_val=read8_i(i+j,values);   // print the 8 byte name
 356          // 			     putchar(out_val);
 357          // 			  }
 358          //               if((attr&0x10)==0x10)  // indicates directory
 359          // 			  {
 360          // 			     for(j=8;j<11;j++)
 361          // 			     {
 362          // 			        out_val=read8_i(i+j,values);
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 7   

 363          // 			        putchar(out_val);
 364          // 			     }
 365          // 			     printf("[DIR]\n");
 366          // 			  }
 367          // 			  else       // print a period and the three byte extension for a file
 368          // 			  {
 369          // 			     putchar(0x2E);
 370          // 			     for(j=8;j<11;j++)
 371          // 			     {
 372          // 			        out_val=read8_i(i+j,values);
 373          // 			        putchar(out_val);
 374          // 			     }
 375          // 			     putchar(0x0d);
 376          //                  putchar(0x0a);
 377          // 			  }
 378          // 		    }
 379          // 		}
 380          // 		    i=i+32;  // next entry
 381          // 		    if(i>510)
 382          // 		    {
 383          // 			  Sector++;
 384          //               if((Sector-Sector_num)<max_sectors)
 385          // 			  {
 386          //                  error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 387          // 			     if(error_flag!=no_errors)
 388          // 			     {
 389          // 			        entries=0;   // no entries found indicates disk read error
 390          // 				    temp8=0;     // forces a function exit
 391          // 			     }
 392          //                  i=0;
 393          // 			  }
 394          // 			  else
 395          // 			  {
 396          // 			     entries=entries|more_entries;  // set msb to indicate more entries in another cluster
 397          // 			     temp8=0;                       // forces a function exit
 398          // 			  }
 399          // 		    }
 400          //
 401          // 	  }while(temp8!=0);
 402          // 	}
 403          // 	else
 404          // 	{
 405          // 	   entries=0;    // no entries found indicates disk read error
 406          // 	}
 407          //    return entries;
 408          //  }
 409          //
 410          //
 411          // /***********************************************************************
 412          // DESC: Uses the same method as Print_Directory to locate short file names,
 413          //       but locates a specified entry and returns and cluster
 414          // INPUT: Starting Sector of the directory, an entry number and a pointer to a
 415          // block of memory in xdata that can be used to read blocks from the SD card
 416          // RETURNS: uint32_t with cluster in lower 28 bits.  Bit 28 set if this is
 417          //          a directory entry, clear for a file.  Bit 31 set for error.
 418          // CAUTION:
 419          // ************************************************************************/
 420          //
 421          // uint32_t Read_Dir_Entry(uint32_t Sector_num, uint16_t Entry, uint8_t xdata * array_in)
 422          // {
 423          //    uint32_t Sector, max_sectors, return_clus;
 424          //    uint16_t i, entries;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 8   

 425          //    uint8_t temp8, attr, error_flag;
 426          //    uint8_t * values;
 427          //
 428          //    values=array_in;
 429          //    entries=0;
 430          //    i=0;
 431          //    return_clus=0;
 432          //    if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 433          //    {
 434          //       max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 435          //    }
 436          //    else
 437          //    {
 438          //       max_sectors=Drive_values.SecPerClus;
 439          //    }
 440          //    Sector=Sector_num;
 441          //    error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 442          //    if(error_flag==no_errors)
 443          //    {
 444          //      do
 445          //      {
 446          //         temp8=read8_i(0+i,values);  // read first byte to see if empty
 447          //         if((temp8!=0xE5)&&(temp8!=0x00))
 448          // 	    {
 449          // 	       attr=read8_i(0x0b+i,values);
 450          // 		   if((attr&0x0E)==0)    // if hidden do not print
 451          // 		   {
 452          // 		      entries++;
 453          //               if(entries==Entry)
 454          //               {
 455          // 			    if(Drive_values.FATtype==FAT32)
 456          //                 {
 457          //                    return_clus=read8_i(21+i,values);
 458          // 				   return_clus=return_clus<<8;
 459          //                    return_clus|=read8_i(20+i,values);
 460          //                    return_clus=return_clus<<8;
 461          //                 }
 462          //                 return_clus|=read8_i(27+i,values);
 463          // 			    return_clus=return_clus<<8;
 464          //                 return_clus|=read8_i(26+i,values);
 465          // 			    attr=read8_i(0x0b+i,values);
 466          // 			    if(attr&0x10) return_clus|=directory_bit;
 467          //                 temp8=0;    // forces a function exit
 468          //               }
 469          //
 470          // 		    }
 471          // 		}
 472          // 		    i=i+32;  // next entry
 473          // 		    if(i>510)
 474          // 		    {
 475          // 			  Sector++;
 476          // 			  if((Sector-Sector_num)<max_sectors)
 477          // 			  {
 478          //                  error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 479          // 			     if(error_flag!=no_errors)
 480          // 			     {
 481          // 			         return_clus=no_entry_found;
 482          //                      temp8=0;
 483          // 			     }
 484          // 			     i=0;
 485          // 			  }
 486          // 			  else
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/21/2019 13:16:06 PAGE 9   

 487          // 			  {
 488          // 			     temp8=0;                       // forces a function exit
 489          // 			  }
 490          // 		    }
 491          //
 492          // 	  }while(temp8!=0);
 493          // 	}
 494          // 	else
 495          // 	{
 496          // 	   return_clus=no_entry_found;
 497          // 	}
 498          // 	if(return_clus==0) return_clus=no_entry_found;
 499          //    return return_clus;
 500          //  }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3093    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3     159
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     24    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
