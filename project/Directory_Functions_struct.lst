C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE DIRECTORY_FUNCTIONS_STRUCT
OBJECT MODULE PLACED IN .\Directory_Functions_struct.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\Directory_Functions_struct.c DEBUG OBJECTEXTEND PRINT(.\Directory
                    -_Functions_struct.lst) OBJECT(.\Directory_Functions_struct.obj) 

stmt level    source

   1          #include "AT89C51RC2.h"
   2          #include <stdio.h>
   3          #include "main.h"
   4          #include "PORT.H"
   5          #include "UART.h"
   6          #include "SPI.h"
   7          #include "SDCard.h"
   8          #include "File_System.h"
   9          #include "print_bytes.h"
  10          #include "Directory_Functions_struct.h"
  11          #include "sector_reader.h"
  12          
  13          
  14          
  15          FS_values_t idata Drive_values;
  16          
  17          // use one of the buffers to store our sectors
  18          extern uint8_t xdata buf1[512];
  19          // use the other as a print buffer
  20          extern uint8_t xdata buf2[512];
  21          // how many bytes are in our print buffer
  22          uint16_t idata print_buffer_pos = 0;
  23          
  24          
  25          // --------- data pool ---------
  26          uint32_t idata pool32[3];
  27          uint16_t idata pool16[2];
  28          uint8_t  idata pool8[4];
  29          
  30          typedef struct
  31          {
  32            uint32_t *Sector;
  33            uint32_t *Sector_num;
  34            uint32_t *max_sectors;
  35            uint16_t *i;
  36            uint16_t *entries;
  37            uint8_t *j;
  38            uint8_t *attr;
  39            uint8_t *out_val;
  40            uint8_t *error_flag;
  41          } print_directory_task_context_t;
  42          // -----------------------------
  43          
  44          void get_print_directory_task_context(print_directory_task_context_t *context)
  45          {
  46   1        context->Sector = pool32 + 0;
  47   1        context->Sector_num = pool32 + 1;
  48   1        context->max_sectors = pool32 + 2;
  49   1      
  50   1        context->i = pool16 + 0;
  51   1        context->entries = pool16 + 1;
  52   1      
  53   1        context->j = pool8 + 0;
  54   1        context->attr = pool8 + 1;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 2   

  55   1        context->out_val = pool8 + 2;
  56   1        context->error_flag = pool8 + 3;
  57   1      }
  58          
  59          uint16_t get_directory_print_buffer_pos(void)
  60          {
  61   1        return print_buffer_pos;
  62   1      }
  63          
  64          void set_directory_print_buffer_pos(uint16_t pos)
  65          {
  66   1        print_buffer_pos = pos;
  67   1      }
  68          
  69          uint8_t get_directory_print_buffer(void)
  70          {
  71   1        return buf2;
  72   1      }
  73          
  74          void print_directory_init(uint32_t sector_number_in)
  75          {
  76   1        print_directory_task_context_t context;
  77   1        get_print_directory_task_context(&context);
  78   1      
  79   1        *context.i=0;
  80   1        if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
  81   1        {
  82   2          *context.max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
  83   2        }
  84   1        else
  85   1        {
  86   2           *context.max_sectors=Drive_values.SecPerClus;
  87   2        }
  88   1        *context.Sector=sector_number_in;
  89   1        *context.Sector_num=sector_number_in;
  90   1        *context.error_flag=Read_Sector(*context.Sector,Drive_values.BytesPerSec,buf1);
  91   1      }
  92          
  93          void read_dir_entry_init()
  94          {
  95   1      
  96   1      }
  97          
  98          
  99          
 100          uint8_t print_directory_task(uint16_t *entries_in)
 101          {
 102   1        uint8_t temp8;
 103   1        print_directory_task_context_t context;
 104   1        uint8_t *values = buf1;
 105   1        get_print_directory_task_context(&context);
 106   1      
 107   1        temp8=read8(0 + *context.i,values);  // read first byte to see if empty
 108   1        if((temp8!=0xE5)&&(temp8!=0x00))
 109   1        {
 110   2          *context.attr=read8(0x0b+ *context.i,values);
 111   2          if(((*context.attr) & 0x0E)==0)   // if hidden, system or Vol_ID bit is set do not print
 112   2          {
 113   3            (*context.entries)++;
 114   3            print_buffer_pos += sprintf(buf2+print_buffer_pos, "%5d. ", *context.entries);  // print entry numbe
             -r with a fixed width specifier
 115   3            for(*context.j=0;*context.j<8;(*context.j)++)
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 3   

 116   3            {
 117   4              *context.out_val=read8(*context.i+*context.j,values);   // print the 8 byte name
 118   4              print_buffer_pos += sprintf(buf2+print_buffer_pos, "%c", *context.out_val);
 119   4            }
 120   3            if(((*context.attr)&0x10)==0x10)  // indicates directory
 121   3            {
 122   4              for(*context.j=8;*context.j<11;(*context.j)++)
 123   4              {
 124   5                *context.out_val=read8(*context.i+*context.j,values);
 125   5                print_buffer_pos += sprintf(buf2+print_buffer_pos, "%c", *context.out_val);
 126   5              }
 127   4              print_buffer_pos += sprintf(buf2+print_buffer_pos, "[DIR]\n");
 128   4            }
 129   3            else       // print a period and the three byte extension for a file
 130   3            {
 131   4              print_buffer_pos += sprintf(buf2+print_buffer_pos, ".", *context.out_val);
 132   4              for(*context.j=8;*context.j<11;(*context.j)++)
 133   4              {
 134   5                *context.out_val=read8(*context.i + *context.j,values);
 135   5                print_buffer_pos += sprintf(buf2+print_buffer_pos, "%c", *context.out_val);
 136   5              }
 137   4              print_buffer_pos += sprintf(buf2+print_buffer_pos, "\r\n", *context.out_val);
 138   4            }
 139   3          }
 140   2        }
 141   1        *context.i=*context.i+32;  // next entry
 142   1        if(*context.i>510)
 143   1        {
 144   2          (*context.Sector)++;
 145   2          if((*context.Sector-*context.Sector_num)<*context.max_sectors)
 146   2          {
 147   3            *context.error_flag=Read_Sector(*context.Sector,Drive_values.BytesPerSec,buf1);
 148   3            if(*context.error_flag!=no_errors)
 149   3            {
 150   4              *context.entries=0;   // no entries found indicates disk read error
 151   4              temp8=0;     // forces a function exit
 152   4            }
 153   3            *context.i=0;
 154   3          }
 155   2          else
 156   2          {
 157   3            *context.entries=*context.entries|more_entries;  // set msb to indicate more entries in another clus
             -ter
 158   3            temp8=0;                       // forces a function exit
 159   3          }
 160   2        }
 161   1        if(temp8==0)
 162   1        {
 163   2          *entries_in = *context.entries;
 164   2          return TASK_COMPLETE;
 165   2        }
 166   1        return TASK_RUNNING;
 167   1      }
 168          //
 169          // uint8_t read_dir_entry_task(uint16_t entry, uint32_t *cluster)
 170          // {
 171          //   uint8_t *values = buf1;
 172          //   temp8=read8(0+i,values);  // read first byte to see if empty
 173          //   if((temp8!=0xE5)&&(temp8!=0x00))
 174          //   {
 175          //     attr=read8(0x0b+i,values);
 176          //     if((attr&0x0E)==0)    // if hidden do not print
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 4   

 177          //     {
 178          //       entries++;
 179          //       if(entries==Entry)
 180          //       {
 181          //         if(Drive_values.FATtype==FAT32)
 182          //         {
 183          //           return_clus=read8(21+i,values);
 184          //           return_clus=return_clus<<8;
 185          //           return_clus|=read8(20+i,values);
 186          //           return_clus=return_clus<<8;
 187          //         }
 188          //         return_clus|=read8(27+i,values);
 189          //         return_clus=return_clus<<8;
 190          //         return_clus|=read8(26+i,values);
 191          //         attr=read8(0x0b+i,values);
 192          //         if(attr&0x10) return_clus|=directory_bit;
 193          //         temp8=0;    // forces a function exit
 194          //       }
 195          //
 196          //     }
 197          //   }
 198          //   i=i+32;  // next entry
 199          //   if(i>510)
 200          //   {
 201          //     Sector++;
 202          //     if((Sector-Sector_num)<max_sectors)
 203          //     {
 204          //       error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 205          //       if(error_flag!=no_errors)
 206          //       {
 207          //         return_clus=no_entry_found;
 208          //         temp8=0;
 209          //       }
 210          //       i=0;
 211          //     }
 212          //     else
 213          //     {
 214          //       temp8=0;                       // forces a function exit
 215          //     }
 216          //   }
 217          //
 218          //   if(temp8 != 0)
 219          //   {
 220          //     return TASK_RUNNING;
 221          //   }
 222          //
 223          //   if(return_clus==0)
 224          //   {
 225          //     *cluster=no_entry_found;
 226          //   }
 227          //   else
 228          //   {
 229          //     *cluster=return_clus;
 230          //   }
 231          //
 232          //   return TASK_COMPLETE;
 233          //  }
 234          
 235          
 236          /***********************************************************************
 237          DESC: Returns a pointer to the global structure Drive_values to export to other files
 238          INPUT: void
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 5   

 239          RETURNS: Pointer to the structure Drive_values
 240          CAUTION:
 241          ************************************************************************/
 242          
 243          FS_values_t * Export_Drive_values(void)
 244          {
 245   1         return &Drive_values;
 246   1      }
 247          
 248          
 249          /***********************************************************************
 250          DESC: Prints all short file name entries for a given directory
 251          INPUT: Starting Sector of the directory and the pointer to a
 252          block of memory in xdata that can be used to read blocks from the SD card
 253          RETURNS: uint16_t number of entries found in the directory
 254          CAUTION: Supports FAT16, SD_shift must be set before using this function
 255          ************************************************************************/
 256          
 257          
 258          
 259          uint16_t  Print_Directory(uint32_t Sector_num, uint8_t xdata * array_in)
 260          {
 261   1         uint32_t Sector, max_sectors;
 262   1         uint16_t i, entries;
 263   1         uint8_t temp8, j, attr, out_val, error_flag;
 264   1         uint8_t * values;
 265   1      
 266   1      
 267   1         values=array_in;
 268   1         entries=0;
 269   1         i=0;
 270   1         if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 271   1         {
 272   2            max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 273   2         }
 274   1         else
 275   1         {
 276   2            max_sectors=Drive_values.SecPerClus;
 277   2         }
 278   1         Sector=Sector_num;
 279   1         error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 280   1         if(error_flag==no_errors)
 281   1         {
 282   2           do
 283   2           {
 284   3              temp8=read8(0+i,values);  // read first byte to see if empty
 285   3              if((temp8!=0xE5)&&(temp8!=0x00))
 286   3      	    {
 287   4      	       attr=read8(0x0b+i,values);
 288   4      		   if((attr&0x0E)==0)   // if hidden, system or Vol_ID bit is set do not print
 289   4      		   {
 290   5      		      entries++;
 291   5      			  printf("%5d. ",entries);  // print entry number with a fixed width specifier
 292   5      		      for(j=0;j<8;j++)
 293   5      			  {
 294   6      			     out_val=read8(i+j,values);   // print the 8 byte name
 295   6      			     putchar(out_val);
 296   6      			  }
 297   5                    if((attr&0x10)==0x10)  // indicates directory
 298   5      			  {
 299   6      			     for(j=8;j<11;j++)
 300   6      			     {
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 6   

 301   7      			        out_val=read8(i+j,values);
 302   7      			        putchar(out_val);
 303   7      			     }
 304   6      			     printf("[DIR]\n");
 305   6      			  }
 306   5      			  else       // print a period and the three byte extension for a file
 307   5      			  {
 308   6      			     putchar(0x2E);
 309   6      			     for(j=8;j<11;j++)
 310   6      			     {
 311   7      			        out_val=read8(i+j,values);
 312   7      			        putchar(out_val);
 313   7      			     }
 314   6      			     putchar(0x0d);
 315   6                       putchar(0x0a);
 316   6      			  }
 317   5      		    }
 318   4      		}
 319   3      		    i=i+32;  // next entry
 320   3      		    if(i>510)
 321   3      		    {
 322   4      			  Sector++;
 323   4                    if((Sector-Sector_num)<max_sectors)
 324   4      			  {
 325   5                       error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 326   5      			     if(error_flag!=no_errors)
 327   5      			     {
 328   6      			        entries=0;   // no entries found indicates disk read error
 329   6      				    temp8=0;     // forces a function exit
 330   6      			     }
 331   5                       i=0;
 332   5      			  }
 333   4      			  else
 334   4      			  {
 335   5      			     entries=entries|more_entries;  // set msb to indicate more entries in another cluster
 336   5      			     temp8=0;                       // forces a function exit
 337   5      			  }
 338   4      		    }
 339   3      
 340   3      	  }while(temp8!=0);
 341   2      	}
 342   1      	else
 343   1      	{
 344   2      	   entries=0;    // no entries found indicates disk read error
 345   2      	}
 346   1         return entries;
 347   1       }
 348          
 349          
 350          /***********************************************************************
 351          DESC: Uses the same method as Print_Directory to locate short file names,
 352                but locates a specified entry and returns and cluster
 353          INPUT: Starting Sector of the directory, an entry number and a pointer to a
 354          block of memory in xdata that can be used to read blocks from the SD card
 355          RETURNS: uint32_t with cluster in lower 28 bits.  Bit 28 set if this is
 356                   a directory entry, clear for a file.  Bit 31 set for error.
 357          CAUTION:
 358          ************************************************************************/
 359          
 360          uint32_t Read_Dir_Entry(uint32_t Sector_num, uint16_t Entry, uint8_t xdata * array_in)
 361          {
 362   1         uint32_t Sector, max_sectors, return_clus;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 7   

 363   1         uint16_t i, entries;
 364   1         uint8_t temp8, attr, error_flag;
 365   1         uint8_t * values;
 366   1      
 367   1         values=array_in;
 368   1         entries=0;
 369   1         i=0;
 370   1         return_clus=0;
 371   1         if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 372   1         {
 373   2            max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 374   2         }
 375   1         else
 376   1         {
 377   2            max_sectors=Drive_values.SecPerClus;
 378   2         }
 379   1         Sector=Sector_num;
 380   1         error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 381   1         if(error_flag==no_errors)
 382   1         {
 383   2           do
 384   2           {
 385   3              temp8=read8(0+i,values);  // read first byte to see if empty
 386   3              if((temp8!=0xE5)&&(temp8!=0x00))
 387   3      	    {
 388   4      	       attr=read8(0x0b+i,values);
 389   4      		   if((attr&0x0E)==0)    // if hidden do not print
 390   4      		   {
 391   5      		      entries++;
 392   5                    if(entries==Entry)
 393   5                    {
 394   6      			    if(Drive_values.FATtype==FAT32)
 395   6                      {
 396   7                         return_clus=read8(21+i,values);
 397   7      				   return_clus=return_clus<<8;
 398   7                         return_clus|=read8(20+i,values);
 399   7                         return_clus=return_clus<<8;
 400   7                      }
 401   6                      return_clus|=read8(27+i,values);
 402   6      			    return_clus=return_clus<<8;
 403   6                      return_clus|=read8(26+i,values);
 404   6      			    attr=read8(0x0b+i,values);
 405   6      			    if(attr&0x10) return_clus|=directory_bit;
 406   6                      temp8=0;    // forces a function exit
 407   6                    }
 408   5      
 409   5      		    }
 410   4      		}
 411   3      		    i=i+32;  // next entry
 412   3      		    if(i>510)
 413   3      		    {
 414   4      			  Sector++;
 415   4      			  if((Sector-Sector_num)<max_sectors)
 416   4      			  {
 417   5                       error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 418   5      			     if(error_flag!=no_errors)
 419   5      			     {
 420   6      			         return_clus=no_entry_found;
 421   6                           temp8=0;
 422   6      			     }
 423   5      			     i=0;
 424   5      			  }
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/20/2019 23:40:29 PAGE 8   

 425   4      			  else
 426   4      			  {
 427   5      			     temp8=0;                       // forces a function exit
 428   5      			  }
 429   4      		    }
 430   3      
 431   3      	  }while(temp8!=0);
 432   2      	}
 433   1      	else
 434   1      	{
 435   2      	   return_clus=no_entry_found;
 436   2      	}
 437   1      	if(return_clus==0) return_clus=no_entry_found;
 438   1         return return_clus;
 439   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2523    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     124
   IDATA SIZE       =     44    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
