C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE SDCARD
OBJECT MODULE PLACED IN .\SDCard.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\SDCard.c LARGE DEBUG OBJECTEXTEND PRINT(.\SDCard.lst) OBJECT(.\SD
                    -Card.obj) 

stmt level    source

   1          #include "AT89C51RC2.h"
   2          #include "PORT.H"
   3          #include "main.h"
   4          #include "SDCard.h"
   5          #include "print_bytes.h"
   6          #include "SPI.h"
   7          #include <stdio.h>
   8          #include "Outputs.h"
   9          #include "LED_Control.h"
  10          
  11          static uint8_t idata SD_Card_Type;
  12          
  13          /***********************************************************************
  14          DESC:    Sends Commands to SD card using the SPI peripheral
  15                   cmnd=Command number to be sent
  16                   argum=32bit argument for a command
  17          RETURNS: error flag
  18          CAUTION: Must be followed by a read to capture SD card response
  19                   nCS0 must be set/cleared outside of this routine
  20          ************************************************************************/
  21          uint8_t SEND_COMMAND(uint8_t cmnd, uint32_t argum)
  22          {
  23   1       uint8_t SPI_send, return_val, SPI_return, error_flag;
  24   1      
  25   1       return_val=no_errors;
  26   1       if(cmnd<64)
  27   1       {
  28   2         SPI_send=cmnd | 0x40;
  29   2         error_flag=SPI_Transfer(SPI_send,&SPI_return);
  30   2         if((error_flag)==no_errors)
  31   2         {
  32   3           SPI_send=argum>>24;   // MSB
  33   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
  34   3         }
  35   2         else
  36   2         {
  37   3           return_val=SPI_error;
  38   3         }
  39   2         if((return_val==no_errors)&&(error_flag==no_errors))
  40   2         {
  41   3           argum=argum & 0x00ffffff;
  42   3           SPI_send=argum>>16;  // BYTE2
  43   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
  44   3         }
  45   2         else
  46   2         {
  47   3           return_val=SPI_error;
  48   3         }
  49   2         if((return_val==no_errors)&&(error_flag==no_errors))
  50   2         {
  51   3           argum=argum & 0x0000ffff;
  52   3           SPI_send=argum>>8;   // BYTE1
  53   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
  54   3         }
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 2   

  55   2         else
  56   2         {
  57   3           return_val=SPI_error;
  58   3         }
  59   2         if((return_val==no_errors)&&(error_flag==no_errors))
  60   2         {
  61   3           SPI_send=argum & 0x000000ff;  // LSB
  62   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
  63   3         }
  64   2         else
  65   2         {
  66   3           return_val=SPI_error;
  67   3         }
  68   2         if((return_val==no_errors)&&(error_flag==no_errors))
  69   2         {
  70   3            if (cmnd == 0)
  71   3            {
  72   4               SPI_send=0x95;  // CRC7 and end bit for CMD0
  73   4            }
  74   3            else if (cmnd == 8)
  75   3            {
  76   4               SPI_send=0x87;   // CRC7 and end bit for CMD8
  77   4            }
  78   3            else
  79   3            {
  80   4               SPI_send=0x01;  // end bit only for other commands
  81   4            }
  82   3            error_flag=SPI_Transfer(SPI_send,&SPI_return);
  83   3          }
  84   2       }
  85   1       else
  86   1       {
  87   2         return_val=illegal_cmnd;
  88   2       }
  89   1       return return_val;
  90   1      }
  91          
  92          
  93          uint8_t SEND_COMMAND_i(uint8_t cmnd, uint32_t argum)
  94          {
  95   1       uint8_t SPI_send, return_val, SPI_return, error_flag;
  96   1      
  97   1       return_val=no_errors;
  98   1       if(cmnd<64)
  99   1       {
 100   2         SPI_send=cmnd | 0x40;
 101   2         error_flag=SPI_Transfer(SPI_send,&SPI_return);
 102   2         if((error_flag)==no_errors)
 103   2         {
 104   3           SPI_send=argum>>24;   // MSB
 105   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
 106   3         }
 107   2         else
 108   2         {
 109   3           return_val=SPI_error;
 110   3         }
 111   2         if((return_val==no_errors)&&(error_flag==no_errors))
 112   2         {
 113   3           argum=argum & 0x00ffffff;
 114   3           SPI_send=argum>>16;  // BYTE2
 115   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
 116   3         }
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 3   

 117   2         else
 118   2         {
 119   3           return_val=SPI_error;
 120   3         }
 121   2         if((return_val==no_errors)&&(error_flag==no_errors))
 122   2         {
 123   3           argum=argum & 0x0000ffff;
 124   3           SPI_send=argum>>8;   // BYTE1
 125   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
 126   3         }
 127   2         else
 128   2         {
 129   3           return_val=SPI_error;
 130   3         }
 131   2         if((return_val==no_errors)&&(error_flag==no_errors))
 132   2         {
 133   3           SPI_send=argum & 0x000000ff;  // LSB
 134   3           error_flag=SPI_Transfer(SPI_send,&SPI_return);
 135   3         }
 136   2         else
 137   2         {
 138   3           return_val=SPI_error;
 139   3         }
 140   2         if((return_val==no_errors)&&(error_flag==no_errors))
 141   2         {
 142   3            if (cmnd == 0)
 143   3            {
 144   4               SPI_send=0x95;  // CRC7 and end bit for CMD0
 145   4            }
 146   3            else if (cmnd == 8)
 147   3            {
 148   4               SPI_send=0x87;   // CRC7 and end bit for CMD8
 149   4            }
 150   3            else
 151   3            {
 152   4               SPI_send=0x01;  // end bit only for other commands
 153   4            }
 154   3            error_flag=SPI_Transfer(SPI_send,&SPI_return);
 155   3          }
 156   2       }
 157   1       else
 158   1       {
 159   2         return_val=illegal_cmnd;
 160   2       }
 161   1       return return_val;
 162   1      }
 163          /***********************************************************************
 164          DESC:    Read values from SPI port, 0xff sent for each byte read
 165          		 num_bytes=number of bytes to read
 166          RETURNS: error flag
 167                   *valout=address of array of bytes read
 168          CAUTION: Used to capture SD card response
 169                   nCS0 must be set/cleared outside of this routine
 170          ************************************************************************/
 171          uint8_t response(uint8_t num_bytes, uint8_t * valout_p)
 172          {
 173   1         uint8_t index,return_val,error_flag, SPI_return;
 174   1      
 175   1         return_val=no_errors;
 176   1         do
 177   1         {
 178   2            error_flag=SPI_Transfer(0xFF,&SPI_return);
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 4   

 179   2            index++;
 180   2         }while(((SPI_return&0x80)==0x80)&&(index!=0)&&(error_flag==no_errors));
 181   1         if(error_flag!=no_errors)
 182   1         {
 183   2            return_val=SPI_error;
 184   2         }
 185   1         else if(index==0)
 186   1         {
 187   2            return_val=sd_timeout_error;
 188   2         }
 189   1         else
 190   1         {
 191   2           *valout_p=SPI_return;
 192   2           if((SPI_return==0x00)||(SPI_return==0x01))
 193   2           {
 194   3             if(num_bytes>1)
 195   3             {
 196   4               for(index=1;index<num_bytes;index++)
 197   4               {
 198   5                  error_flag=SPI_Transfer(0xFF,&SPI_return);
 199   5                  *(valout_p+index)=SPI_return;
 200   5               }
 201   4             }
 202   3           }
 203   2           else
 204   2           {
 205   3              return_val=response_error;
 206   3           }
 207   2         }
 208   1         error_flag=SPI_Transfer(0xFF,&SPI_return);  // send 8 more clock cycles to complete read
 209   1         return return_val;
 210   1      }
 211          
 212          
 213          /**********************************************************************
 214          DESC:    Reads a specifed number of bytes from SD card,
 215                   0xff sent for each byte read
 216          RETURNS: error flag
 217                   block of data stored in array_out[]
 218          CAUTION: Used to capture SD card response
 219                   nCS0 must be set/cleared outside of this routine
 220          ************************************************************************/
 221          uint8_t read_block(uint16_t num_bytes, uint8_t * array_out_p)
 222          {
 223   1         uint8_t error_flag,return_val,SPI_return;
 224   1         uint16_t index;
 225   1         index=0;
 226   1         return_val=no_errors;
 227   1         do
 228   1         {
 229   2            error_flag=SPI_Transfer(0xFF,&SPI_return);
 230   2            index++;
 231   2         }while(((SPI_return&0x80)==0x80)&&(index!=0)&&(error_flag==no_errors));
 232   1         if(error_flag!=no_errors)
 233   1         {
 234   2            return_val=SPI_error;
 235   2         }
 236   1         else if(index==0)
 237   1         {
 238   2            return_val=sd_timeout_error;
 239   2         }
 240   1         else
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 5   

 241   1         {
 242   2           if (SPI_return==0x00)
 243   2           {
 244   3              index=0;
 245   3      	    do
 246   3              {
 247   4                 error_flag=SPI_Transfer(0xFF,&SPI_return);
 248   4                 index++;
 249   4              }while((SPI_return==0xFF)&&(index!=0)&&(error_flag==no_errors));          // wait for data token r
             -esponse
 250   3              if(error_flag!=no_errors)
 251   3              {
 252   4                 return_val=SPI_error;
 253   4              }
 254   3              else if(index==0)
 255   3              {
 256   4                return_val=sd_timeout_error;
 257   4              }
 258   3              else if(SPI_return==0xfe)
 259   3              {
 260   4                for(index=0;index<num_bytes;index++)
 261   4                {
 262   5                   error_flag=SPI_Transfer(0xFF,&SPI_return);
 263   5                   *(array_out_p + index)=SPI_return;
 264   5                }
 265   4                error_flag=SPI_Transfer(0xFF,&SPI_return); // discard byte 1 of CRC16
 266   4                error_flag=SPI_Transfer(0xFF,&SPI_return); // discard byte 2 of CRC16
 267   4              }
 268   3      	    else
 269   3      	    {
 270   4      	      return_val=data_error;
 271   4      	    }
 272   3           }
 273   2           else
 274   2           {
 275   3              return_val=response_error;
 276   3           }
 277   2         }
 278   1       error_flag=SPI_Transfer(0xFF,&SPI_return);// send 8 more clock cycles to complete read
 279   1      return return_val;
 280   1      }
 281          
 282          uint8_t read_block_i(uint16_t num_bytes, uint8_t * array_out_p)
 283          {
 284   1         uint8_t error_flag,return_val,SPI_return;
 285   1         uint16_t index;
 286   1         index=0;
 287   1         return_val=no_errors;
 288   1         do
 289   1         {
 290   2            error_flag=SPI_Transfer(0xFF,&SPI_return);
 291   2            index++;
 292   2         }while(((SPI_return&0x80)==0x80)&&(index!=0)&&(error_flag==no_errors));
 293   1         if(error_flag!=no_errors)
 294   1         {
 295   2            return_val=SPI_error;
 296   2         }
 297   1         else if(index==0)
 298   1         {
 299   2            return_val=sd_timeout_error;
 300   2         }
 301   1         else
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 6   

 302   1         {
 303   2           if (SPI_return==0x00)
 304   2           {
 305   3              index=0;
 306   3      	    do
 307   3              {
 308   4                 error_flag=SPI_Transfer(0xFF,&SPI_return);
 309   4                 index++;
 310   4              }while((SPI_return==0xFF)&&(index!=0)&&(error_flag==no_errors));          // wait for data token r
             -esponse
 311   3              if(error_flag!=no_errors)
 312   3              {
 313   4                 return_val=SPI_error;
 314   4              }
 315   3              else if(index==0)
 316   3              {
 317   4                return_val=sd_timeout_error;
 318   4              }
 319   3              else if(SPI_return==0xfe)
 320   3              {
 321   4                for(index=0;index<num_bytes;index++)
 322   4                {
 323   5                   error_flag=SPI_Transfer(0xFF,&SPI_return);
 324   5                   *(array_out_p + index)=SPI_return;
 325   5                }
 326   4                error_flag=SPI_Transfer(0xFF,&SPI_return); // discard byte 1 of CRC16
 327   4                error_flag=SPI_Transfer(0xFF,&SPI_return); // discard byte 2 of CRC16
 328   4              }
 329   3      	    else
 330   3      	    {
 331   4      	      return_val=data_error;
 332   4      	    }
 333   3           }
 334   2           else
 335   2           {
 336   3              return_val=response_error;
 337   3           }
 338   2         }
 339   1       error_flag=SPI_Transfer(0xFF,&SPI_return);// send 8 more clock cycles to complete read
 340   1      return return_val;
 341   1      }
 342          
 343          /**********************************************************************
 344          DESC:    Sends the commands needed to initialize the SD card
 345          RETURNS: error flag
 346          CAUTION:
 347          ************************************************************************/
 348          uint8_t SD_card_init(void)
 349          {
 350   1         uint8_t i,error_status,error_flag,valsout[8],SPI_return;
 351   1         uint32_t argument;
 352   1         uint32_t timeout;
 353   1         error_status=no_errors;
 354   1         SD_Card_Type=unknown;
 355   1         SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 356   1         printf("SD Card Initialization ... \n\r");
 357   1         for(i=0;i<10;i++)
 358   1         {
 359   2             error_flag=SPI_Transfer(0xFF,&SPI_return);
 360   2         }
 361   1         LEDS_ON(Green_LED);  //GREENLED=0;
 362   1         printf("CMD0 sent ... ");
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 7   

 363   1         SPI_Select_Clear(SD_Card_Select); //nCS0=0;  // SD card CS low
 364   1         error_flag=SEND_COMMAND(CMD0,0);
 365   1         if(error_flag==no_errors)
 366   1         {
 367   2           error_flag=response(1,valsout);
 368   2           printf("Response = %2.2bX\n\r",valsout[0]);
 369   2         }
 370   1         else
 371   1         {
 372   2      	 LEDS_ON(Red_LED); //REDLED=0;  // indicates error has occured.
 373   2         }
 374   1         SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 375   1         LEDS_OFF(Green_LED); //GREENLED=1;
 376   1         if(error_flag!=no_errors)
 377   1         {
 378   2           error_status=error_flag;
 379   2         }
 380   1         if(error_status==no_errors)
 381   1         {
 382   2           LEDS_ON(Green_LED);  //GREENLED=0;
 383   2           printf("CMD8 sent ... ");
 384   2           SPI_Select_Clear(SD_Card_Select); //nCS0=0;  // SD card CS low
 385   2           error_flag=SEND_COMMAND(CMD8,0x000001AA);
 386   2      	 if(error_flag==no_errors)
 387   2           {
 388   3              error_flag=response(5,valsout);
 389   3      		SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 390   3      		LEDS_OFF(Green_LED); //GREENLED=1;
 391   3      	    if(error_flag!=no_errors)
 392   3      	    {
 393   4      	        printf("Response = ");
 394   4      		    printf("%2.2bX \n\r",valsout[0]);
 395   4      		    if((error_flag==response_error)&&(valsout[0]==0x05))
 396   4                  {
 397   5                      error_status=no_errors;
 398   5      		        SD_Card_Type=Standard_Capacity;
 399   5      		        printf("Version 1 SD Card detected.\n\r");
 400   5      		        printf("Standard Capacity Card detected.\n\r");
 401   5                   }
 402   4      		     else
 403   4      		     {
 404   5      		        error_status=error_flag;
 405   5      		     }
 406   4      	    }
 407   3      		else
 408   3      		{
 409   4      	        printf("Response = ");
 410   4                  for(i=0;i<5;i++)
 411   4      		    {
 412   5      		        printf("%2.2bX ",valsout[i]);
 413   5      		    }
 414   4                  putchar(CR);
 415   4                  putchar(LF);
 416   4      		    if(valsout[4]!=0xAA)
 417   4      		    {
 418   5      		        error_flag=response_error;
 419   5      		    }
 420   4      			SD_Card_Type=Ver2;
 421   4      		    printf("Version 2 SD Card detected.\n\r");
 422   4               }
 423   3      	 }
 424   2           else
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 8   

 425   2           {
 426   3              SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 427   3              LEDS_OFF(Green_LED); //GREENLED=1;
 428   3      	    LEDS_ON(Red_LED); //REDLED=0;  // indicates error has occured.
 429   3           }
 430   2         }
 431   1         if(error_status==no_errors)
 432   1         {
 433   2           LEDS_ON(Green_LED);  //GREENLED=0;
 434   2           printf("CMD58 sent ... ");
 435   2           SPI_Select_Clear(SD_Card_Select); //nCS0=0;  // SD card CS low
 436   2           error_flag=SEND_COMMAND(CMD58,0);
 437   2      	 if(error_flag==no_errors)
 438   2           {
 439   3              error_flag=response(5,valsout);
 440   3      		SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 441   3      		LEDS_OFF(Green_LED); //GREENLED=1;
 442   3      	    printf("Response = ");
 443   3              for(i=0;i<5;i++)
 444   3      		{
 445   4      		     printf("%2.2bX ",valsout[i]);
 446   4      		}
 447   3              putchar(CR);
 448   3              putchar(LF);
 449   3      		if((valsout[2]&0xFC)!=0xFC)
 450   3      		{
 451   4      		   error_flag=voltage_error;
 452   4      		}
 453   3           }
 454   2           else
 455   2           {
 456   3              SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 457   3              LEDS_OFF(Green_LED); //GREENLED=1;
 458   3      	    LEDS_ON(Red_LED); //REDLED=0;  // indicates error has occured.
 459   3           }
 460   2      	 if(error_flag!=no_errors)
 461   2      	 {
 462   3      	    error_status=error_flag;
 463   3      	 }
 464   2         }
 465   1         if(error_status==no_errors)
 466   1         {
 467   2           if(SD_Card_Type==Ver2)
 468   2      	 {
 469   3      	    argument=0x40000000;
 470   3      	 }
 471   2      	 else
 472   2      	 {
 473   3      	    argument=0;
 474   3      	 }
 475   2      	 timeout=0;
 476   2           LEDS_ON(Yellow_LED);  //GREENLED=0;
 477   2           printf("ACMD41 sent ... ");
 478   2           //SPI_Select_Clear(SD_Card_Select); //nCS0=0;  // SD card CS low
 479   2      	 do
 480   2      	 {
 481   3      	    SPI_Select_Clear(SD_Card_Select); //nCS0=0;  // SD card CS low
 482   3      	    error_flag=SEND_COMMAND(CMD55,0);
 483   3      		if(error_flag==no_errors)  error_flag=response(1,valsout);
 484   3      		//P3_5=1;
 485   3      	    if((valsout[0]==0x01)||(valsout[0]==0x00))
 486   3      		   error_flag=SEND_COMMAND(ACMD41,argument);
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 9   

 487   3      	    if(error_flag==no_errors) response(1,valsout);
 488   3              SPI_Select_Set(SD_Card_Select); //nCS0=1;
 489   3              //printf("Response = %2.2bX\n\r",valsout[0]);
 490   3      		timeout++;
 491   3      		if(timeout==0) error_flag=sd_timeout_error;
 492   3      	   }while(((valsout[0]&0x01)==0x01)&&(error_flag==no_errors));
 493   2      	 if(error_flag==no_errors)
 494   2           {
 495   3              LEDS_OFF(Yellow_LED); //GREENLED=1;
 496   3      	    printf("Response = %2.2bX\n\r",valsout[0]);
 497   3           }
 498   2           else
 499   2           {
 500   3              LEDS_OFF(Green_LED); //GREENLED=1;
 501   3      	    LEDS_ON(Red_LED); //REDLED=0;  // indicates error has occured.
 502   3           }
 503   2           //SPI_Select_Set(SD_Card_Select);
 504   2           printf("Timeout = %lu \n\r",timeout);
 505   2      	 if(error_flag!=no_errors)
 506   2      	 {
 507   3      	    error_status=error_flag;
 508   3      	 }
 509   2         }
 510   1         if((error_status==no_errors)&&(SD_Card_Type==Ver2))
 511   1         {
 512   2           LEDS_ON(Green_LED);  //GREENLED=0;
 513   2           printf("CMD58 sent ... ");
 514   2           SPI_Select_Clear(SD_Card_Select); //nCS0=0;  // SD card CS low
 515   2           error_flag=SEND_COMMAND(CMD58,0);
 516   2      	 if(error_flag==no_errors)
 517   2           {
 518   3              error_flag=response(5,valsout);
 519   3      		SPI_Select_Set(SD_Card_Select); //nCS0=1;
 520   3              LEDS_OFF(Green_LED); //GREENLED=1;
 521   3      	    printf("Response = ");
 522   3              for(i=0;i<5;i++)
 523   3      		{
 524   4                 printf("%2.2bX ",valsout[i]);
 525   4      		}
 526   3              putchar(CR);
 527   3              putchar(LF);
 528   3      		if((valsout[1]&0x80)!=0x80)
 529   3      		{
 530   4      		   error_flag=card_inactive;
 531   4      		}
 532   3      		else
 533   3      		{
 534   4      		   if((valsout[1]&0xC0)==0xC0)
 535   4      		   {
 536   5      		      SD_Card_Type=High_Capacity;
 537   5      		      printf("High Capacity Card Detected\n\r");
 538   5      		   }
 539   4      		   else
 540   4      		   {
 541   5      		      SD_Card_Type=Standard_Capacity;
 542   5      			  printf("Standard Capacity Card Detected\n\r");
 543   5      			  LEDS_ON(Green_LED);  //GREENLED=0;
 544   5                    printf("CMD16 sent ... ");
 545   5                    SPI_Select_Clear(SD_Card_Select); //nCS0=0;  // SD card CS low
 546   5                    error_flag=SEND_COMMAND(CMD16,512);
 547   5      	          if(error_flag==no_errors)
 548   5                    {
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 10  

 549   6                        error_flag=response(1,valsout);
 550   6      		          SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 551   6                        LEDS_OFF(Green_LED); //GREENLED=1;
 552   6      	              printf("Response = %2.2bX \n\r",valsout[0]);
 553   6                        printf("Block size set to 512 bytes\n\r");
 554   6      		      }
 555   5      			}
 556   4      		 }
 557   3           }
 558   2           else
 559   2           {
 560   3              SPI_Select_Set(SD_Card_Select);  //nCS0=1;
 561   3              LEDS_OFF(Green_LED); //GREENLED=1;
 562   3      	    LEDS_ON(Red_LED); //REDLED=0;  // indicates error has occured.
 563   3           }
 564   2      	 if(error_flag!=no_errors)
 565   2      	 {
 566   3      	    error_status=error_flag;
 567   3      		print_error(error_status);
 568   3      	 }
 569   2         }
 570   1       if(error_status!=no_errors)
 571   1       {
 572   2      	print_error(error_status);
 573   2       }
 574   1      return error_status;
 575   1      }
 576          
 577          /**********************************************************************
 578          DESC:    Returns the SD card type
 579          RETURNS: SD_Card_Type
 580          CAUTION: SD card must be initialized first
 581          ************************************************************************/
 582          
 583          uint8_t Return_SD_Card_Type(void)
 584          {
 585   1         return SD_Card_Type;
 586   1      }
 587          
 588          /**********************************************************************
 589          DESC:    Prints an error text based on the error code
 590          RETURNS: nothing
 591          CAUTION: Mainly used for debugging
 592          ***********************************************************************/
 593          
 594          
 595          void print_error(uint8_t error)
 596          {
 597   1         if(error==sd_timeout_error) printf("SD Timeout Error");
 598   1         else if(error==illegal_cmnd) printf("Illegal Command\n\r");
 599   1         else if(error==response_error) printf("Response Error");
 600   1         else if(error==data_error) printf("Data Token Error");
 601   1         else if(error==voltage_error) printf("Incompatible Voltage");
 602   1         else if(error==card_inactive) printf("Card is Inactive");
 603   1         else if(error==SPI_error) printf("SPI or Timeout Error");
 604   1         else printf("Unknown Error");
 605   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3126    ----
   CONSTANT SIZE    =    526    ----
C51 COMPILER V6.02  SDCARD                                                                 11/21/2019 13:16:06 PAGE 11  

   XDATA SIZE       =   ----      67
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
